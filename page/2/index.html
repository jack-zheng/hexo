<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/hexo/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hexo/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hexo/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hexo/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="UgODgWVmvTsdD--vjodDR3tPUZRWM3i7JpHzbYejxUM">

<link rel="stylesheet" href="/hexo/css/main.css">


<link rel="stylesheet" href="/hexo/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hexo/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="我是张江搬砖小码农, 知识搬运工">
<meta property="og:type" content="website">
<meta property="og:title" content="Jackpot">
<meta property="og:url" content="https://jack-zheng.github.io/hexo/page/2/index.html">
<meta property="og:site_name" content="Jackpot">
<meta property="og:description" content="我是张江搬砖小码农, 知识搬运工">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jack Zheng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jack-zheng.github.io/hexo/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Jackpot</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/hexo/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jackpot</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-tags">

    <a href="/hexo/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/hexo/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hexo/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/jack-zheng" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jack-zheng.github.io/hexo/hexo/2021/09/16/HTW-ex13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/jack.jpg">
      <meta itemprop="name" content="Jack Zheng">
      <meta itemprop="description" content="我是张江搬砖小码农, 知识搬运工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackpot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/09/16/HTW-ex13/" class="post-title-link" itemprop="url">Ex13 Engine 和 Host</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-16 14:12:43" itemprop="dateCreated datePublished" datetime="2021-09-16T14:12:43+08:00">2021-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-14 10:41:39" itemprop="dateModified" datetime="2021-10-14T10:41:39+08:00">2021-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>Chapter 13</strong> presents the two other containers: host and engine. You can also find the standard implementation of these two containers: org.apache.catalina.core.StandardHost and org.apache.catalina.core.StandardEngine.</p>
</blockquote>
<p>介绍了另外两个 Container 概念：engine 和 host。如果你的系统需要有一个以上的 context，那你就需要 host 了。如果只有一个 context，理论上可以不用 host。</p>
<h2 id="The-Host-Interface"><a href="#The-Host-Interface" class="headerlink" title="The Host Interface"></a>The Host Interface</h2><p>Container 的一个接口实现，最重要的方法为 map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the Context that would be used to process the specified</span></span><br><span class="line"><span class="comment">* host-relative request URI, if any; otherwise return &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> uri Request URI to be mapped</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">map</span><span class="params">(String uri)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="StandardHost"><a href="#StandardHost" class="headerlink" title="StandardHost"></a>StandardHost</h2><p>Host 的具体实现，也没什么新鲜的，还是 Container + pipeline + valve 三件套。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StandardHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    pipeline.setBasic(<span class="keyword">new</span> StandardHostValve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在它的 start() 方法中还会添加两个新的 valve 进 pipeline, 一个是 ErrorReportValve 另一个是 ErrorDispatcherValve</p>
<p>StandardHost 的 map() 用来寻找匹配的 context。</p>
<p>PS: Tomcat 5 已经不用 Mapper 机制的，直接从 request 中找到正确的 context</p>
<h2 id="StandardHostMapper"><a href="#StandardHostMapper" class="headerlink" title="StandardHostMapper"></a>StandardHostMapper</h2><p>略</p>
<h2 id="StandardHostValve"><a href="#StandardHostValve" class="headerlink" title="StandardHostValve"></a>StandardHostValve</h2><p>里面有涉及 Session 的操作，挺有意思</p>
<h2 id="Why-You-Cannot-Live-without-a-Host"><a href="#Why-You-Cannot-Live-without-a-Host" class="headerlink" title="Why You Cannot Live without a Host"></a>Why You Cannot Live without a Host</h2><p>如果你的应用使用了默认的 ContextConfig 作为配置的对象，那你必须创建 Host。因为它的加载配置文件的方法 applicationConfig() 的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URL url = servletContext.getResource(Constants.ApplicationWebXml);</span><br><span class="line"></span><br><span class="line">InputSource is = <span class="keyword">new</span> InputSource(url.toExternalForm());</span><br><span class="line">is.setByteStream(stream);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">webDigester.parse(is);</span><br></pre></td></tr></table></figure>

<p>servletContext 的实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String path)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">    DirContext resources = context.getResources();</span><br><span class="line">    <span class="keyword">if</span> (resources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String fullPath = context.getName() + path;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this is the problem. Host must not be null</span></span><br><span class="line">        String hostName = context.getParent().getName();</span><br><span class="line">        <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>最后一行表示，当使用 ContextConfig 时，你必须有一个 Host 类型的 parent</p>
<h2 id="Bootstrap1"><a href="#Bootstrap1" class="headerlink" title="Bootstrap1"></a>Bootstrap1</h2><p>使用 Host 的案例</p>
<h2 id="The-Engine-Interface"><a href="#The-Engine-Interface" class="headerlink" title="The Engine Interface"></a>The Engine Interface</h2><p>Engin 表示整个 Catalina servlet engine, 让你想要你的应用有多个 Host 的时候可以使用它。</p>
<p>对应的实现是 org.apache.catalina.core.StandardEngine。和其他 Container 实现相比，StandardEngine 要单薄的多。套路还是一样，结合 valve 使用。在 addChild() 时，如果不是 Host 类型的 container 会抛异常。 setParent() 时，由于它是顶层 Container，setParent() 会抛异常。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>按理来说，学到这里应该就可以设置一个网站，多个域名了，怎么实现？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jack-zheng.github.io/hexo/hexo/2021/09/15/HTW-ex12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/jack.jpg">
      <meta itemprop="name" content="Jack Zheng">
      <meta itemprop="description" content="我是张江搬砖小码农, 知识搬运工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackpot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/09/15/HTW-ex12/" class="post-title-link" itemprop="url">Ex12 StandardContext</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-15 19:52:57" itemprop="dateCreated datePublished" datetime="2021-09-15T19:52:57+08:00">2021-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-14 10:41:39" itemprop="dateModified" datetime="2021-10-14T10:41:39+08:00">2021-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>Chapter 12</strong> covers the org.apache.catalina.core.StandardContext class that represents a web application. In particular this chapter discusses how a StandardContext object is configured, what happens in it for each incoming HTTP request, how it supports automatic reloading, and how Tomcat 5 shares a thread that executes periodic tasks in its associated components.</p>
</blockquote>
<p>本章沿用 11 章的代码，主要介绍一下内容</p>
<ul>
<li>StanadradContextMapper 和 ContextConfig</li>
<li>Http request 接收到之后的调用链</li>
<li>StandardContext 中的重要属性</li>
<li>Tomcat 5 中的 backgroundProcess</li>
</ul>
<h2 id="StandardContext-Configuration"><a href="#StandardContext-Configuration" class="headerlink" title="StandardContext Configuration"></a>StandardContext Configuration</h2><p>创建完 StandardContext 的实例后必须调用一下他的 start() 方法，这个过程中他会做以下事情</p>
<ul>
<li>置位 available flag</li>
<li>读取 CATALINA_HOME/conf 路径下的配置文件</li>
<li>在 listener 中进行 context 的配置</li>
</ul>
<p>细节在 15 章中再讲</p>
<h3 id="StandardContext-Class’s-Constructor"><a href="#StandardContext-Class’s-Constructor" class="headerlink" title="StandardContext Class’s Constructor"></a>StandardContext Class’s Constructor</h3><p>构造函数，设置默认的 valve</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StandardContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    pipeline.setBasic(<span class="keyword">new</span> StandardContextValve());</span><br><span class="line">    namingResources.setContainer(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Starting-StandardContext"><a href="#Starting-StandardContext" class="headerlink" title="Starting StandardContext"></a>Starting StandardContext</h3><p>只要做了 flag 置位和 listener 的处理，代码很清楚，主要做了如下事情</p>
<ul>
<li>fire BEFORE_START event</li>
<li>availability flag 置位</li>
<li>configured flag 置位</li>
<li>set resources</li>
<li>set manager</li>
<li>init character set manager</li>
<li>启动 context 相关联的其他 component</li>
<li>启动子 container</li>
<li>启动 pipeline</li>
<li>启动 manager</li>
<li>fire START event, listener(ContextConfig) 会进行一些配置，成功了之后 configured flag 置位</li>
<li>如果 configured 为 true，进行一些其他配置工作</li>
<li>fire AFTER_START event</li>
</ul>
<p>PS: Tomcat 5 中逻辑基本一致，此外还增加了 JMX 相关的代码</p>
<h2 id="StandardContextMapper"><a href="#StandardContextMapper" class="headerlink" title="StandardContextMapper"></a>StandardContextMapper</h2><p>StandardContext 的 invoke 方法调用时，会调用自己的 StandardContextValve 的 invoke 方法，它做的第一件事是拿到处理 request 匹配的 wrapper。</p>
<p>ContainerBase 类中有 addDefaultMapper() 方法，实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addDefaultMapper</span><span class="params">(String mapperClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do we need a default Mapper?</span></span><br><span class="line">    <span class="keyword">if</span> (mapperClass == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (mappers.size() &gt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate and add a default Mapper</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class clazz = Class.forName(mapperClass);</span><br><span class="line">        Mapper mapper = (Mapper) clazz.newInstance();</span><br><span class="line">        mapper.setProtocol(<span class="string">&quot;http&quot;</span>);</span><br><span class="line">        addMapper(mapper);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log(sm.getString(<span class="string">&quot;containerBase.addDefaultMapper&quot;</span>, mapperClass),</span><br><span class="line">            e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StandardContext 中定义了对应的 mapperClass 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String mapperClass = <span class="string">&quot;org.apache.catalina.core.StandardContextMapper&quot;</span></span><br></pre></td></tr></table></figure>

<p>Mapper 中最核心的方法为 map 方法 <code>public Container map(Request request, boolean update)</code> 返回 request 对应的 wrapper。mapper 中会一次通过四种筛选条件过滤出目标 wrapper</p>
<ul>
<li>精确匹配</li>
<li>前缀匹配</li>
<li>后缀匹配</li>
<li>默认匹配</li>
</ul>
<p>如果还是没找到，就返回 null. Tomcat 5 中做了改进，直接从 request 中可以拿到对应的 wrapper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wrapper wrapper = request.getWrapper();</span><br></pre></td></tr></table></figure>

<h2 id="Support-for-Reloading"><a href="#Support-for-Reloading" class="headerlink" title="Support for Reloading"></a>Support for Reloading</h2><p>StandardContext 中又一个 reloadable 属性，当 web.xml 改变或者 WEB-INF/classes 文件夹下文件发生改变时，这个 flag 会置位</p>
<p>StandardContext 的 loader - WebappLoader 在执行 setContainer 时会启动一个线程，当上述目录的文件发生改变，loader 会重新加载 application</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Set the Container with which this Logger has been associated.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> container The associated Container</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deregister from the old Container (if any)</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.container != <span class="keyword">null</span>) &amp;&amp; (<span class="keyword">this</span>.container <span class="keyword">instanceof</span> Context))</span><br><span class="line">        ((Context) <span class="keyword">this</span>.container).removePropertyChangeListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process this property change</span></span><br><span class="line">    Container oldContainer = <span class="keyword">this</span>.container;</span><br><span class="line">    <span class="keyword">this</span>.container = container;</span><br><span class="line">    support.firePropertyChange(<span class="string">&quot;container&quot;</span>, oldContainer, <span class="keyword">this</span>.container);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register with the new Container (if any)</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.container != <span class="keyword">null</span>) &amp;&amp; (<span class="keyword">this</span>.container <span class="keyword">instanceof</span> Context)) &#123;</span><br><span class="line">        setReloadable( ((Context) <span class="keyword">this</span>.container).getReloadable() );</span><br><span class="line">        ((Context) <span class="keyword">this</span>.container).addPropertyChangeListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一段的 setReloadable() 方法实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Set the reloadable flag for this Loader.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> reloadable The new reloadable flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReloadable</span><span class="params">(<span class="keyword">boolean</span> reloadable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process this property change</span></span><br><span class="line"><span class="keyword">boolean</span> oldReloadable = <span class="keyword">this</span>.reloadable;</span><br><span class="line"><span class="keyword">this</span>.reloadable = reloadable;</span><br><span class="line">support.firePropertyChange(<span class="string">&quot;reloadable&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> Boolean(oldReloadable),</span><br><span class="line">                            <span class="keyword">new</span> Boolean(<span class="keyword">this</span>.reloadable));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start or stop our background thread if required</span></span><br><span class="line"><span class="keyword">if</span> (!started)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (!oldReloadable &amp;&amp; <span class="keyword">this</span>.reloadable)</span><br><span class="line">    threadStart();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldReloadable &amp;&amp; !<span class="keyword">this</span>.reloadable)</span><br><span class="line">    threadStop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>threadStart() 会启动一个线程，持续监测 WEB-INF 文件夹下文件的时间戳，threadStop() 则用来停止这个线程</p>
<p>PS：Tomcat 5 中这个监测过程使用专门的 backgroundProcess 来完成</p>
<h2 id="The-backgroundProcess-Method"><a href="#The-backgroundProcess-Method" class="headerlink" title="The backgroundProcess Method"></a>The backgroundProcess Method</h2><p>略</p>
<p>PS：这本书看完之后，为了巩固他，可以看看 Stackoverflow 上 Tomcat 相关的问题，找找灵感</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jack-zheng.github.io/hexo/hexo/2021/09/14/HTW-ex11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/jack.jpg">
      <meta itemprop="name" content="Jack Zheng">
      <meta itemprop="description" content="我是张江搬砖小码农, 知识搬运工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackpot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/09/14/HTW-ex11/" class="post-title-link" itemprop="url">Ex11 StandardWrapper</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-14 16:15:04" itemprop="dateCreated datePublished" datetime="2021-09-14T16:15:04+08:00">2021-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-14 10:41:39" itemprop="dateModified" datetime="2021-10-14T10:41:39+08:00">2021-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>Chapter 11</strong> explains in detail the org.apache.catalina.core.StandardWrapper class that represents a servlet in a web application. In particular, this chapter explains how filters and a servlet’s service method are invoked. The application accompanying this chapter uses StandardWrapper instances to represents servlets.</p>
</blockquote>
<p>本章主要介绍 Tomcat 的默认 Wrapper 实现，已经相关的接口 SingleThreadModel</p>
<h2 id="Sequence-of-Methods-Invocation"><a href="#Sequence-of-Methods-Invocation" class="headerlink" title="Sequence of Methods Invocation"></a>Sequence of Methods Invocation</h2><p>当 connector 收到一个 HTTP request 之后，调用链如下</p>
<p><img src="ex11_method_invocation.png" alt="method invocation"></p>
<p>主要步骤：</p>
<ul>
<li>connector 创建 request/response 实例</li>
<li>connector 调用 StandardContext 的 invoke 方法</li>
<li>StandardContext 调用 StandardContextValve 的 invoke 方法</li>
<li>StandardContextValve 找到对应的 wrapper 并调用其 invoke 方法</li>
<li>wrapper 调用对应的 StandardWrapperValve 的 invoke 方法</li>
<li>StandardWrapperValve 调用 wrapper 的 allocate() 方法加载 servlet 实例</li>
<li>allocate 调用 load 方法加载 servlet</li>
<li>load 方法调用 servlet 的 init 方法</li>
<li>StandardWrapperValve 调用 servlet 的 service 方法</li>
</ul>
<h2 id="SingleThreadModel"><a href="#SingleThreadModel" class="headerlink" title="SingleThreadModel"></a>SingleThreadModel</h2><p>servlet 可以选择实现 javax.servlet.SingleThreadMode 接口，实现了该接口的 class 称为 SingleThreadModel (STM) servlet。</p>
<p>Servlet 2.4 specification 中关于这个借口的描述如下: </p>
<blockquote>
<p>If a servlet implements this interface, you are guaranteed that no two threads will execute concurrently in a servlet’s service method. The servlet container can guarantee this by synchronizing access to a single instance of the servlet,<br>or by maintaining a pool of servlet instances and dispatching each new request to a free servlet. This interface does not prevent synchronization problems that result from servlets accessing shared resources such as static class variables or classes outside the scope of the servlet.</p>
</blockquote>
<p>实现这个接口可以保证再一个时间点上，只有一个 servlet 被处理。实现方式可能是 synchronized 或者 pool，但这并不意味着保证线程安全。比如一些静态变量，或者共享资源的调用还是有可能会长生多线程问题的。</p>
<p>It is true that by implementing SingleThreadModel no two threads will execute a servlet’s service method at the same time. However, to enhance performance the servlet container can create multiple instances of an STM servlet. That means, the STM servlet’s service method can be executed concurrently in different instances. This will introduce synchronization problems if the servlet need to access static class variables or other resources outside the class.</p>
<h2 id="StandardWrapper"><a href="#StandardWrapper" class="headerlink" title="StandardWrapper"></a>StandardWrapper</h2><p>StandardWrapper 的职责是加载对应的 servlet 并创建实例，调用 servlet 的 service 方法并不在它的职责范围内，是由 StandardWrapperValve 完成的。具体的调用点是在 ApplicationFilterChain 类中。</p>
<p>加载在 <code>StandardWrapper#loadServlet</code> 中完成，过程的后段会置位 singleThreadModel flag</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register our newly initialized instance</span></span><br><span class="line">singleThreadModel = servlet <span class="keyword">instanceof</span> SingleThreadModel;</span><br><span class="line"><span class="keyword">if</span> (singleThreadModel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (instancePool == <span class="keyword">null</span>)</span><br><span class="line">        instancePool = <span class="keyword">new</span> Stack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StandardWrapper#allocate</code> 实现如下, 主要逻辑如下</p>
<ol>
<li>加载目标 servlet</li>
<li>置位 singleThreadModel flag</li>
<li>根据 flag 选择对应的维护 servlet 的形式，单例模式/Pool</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Servlet <span class="title">allocate</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug &gt;= <span class="number">1</span>)</span><br><span class="line">        log(<span class="string">&quot;Allocating an instance&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are currently unloading this servlet, throw an exception</span></span><br><span class="line">    <span class="keyword">if</span> (unloading)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">            (sm.getString(<span class="string">&quot;standardWrapper.unloading&quot;</span>, getName()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If not SingleThreadedModel, return the same instance every time</span></span><br><span class="line">    <span class="keyword">if</span> (!singleThreadModel) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load and initialize our instance if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        instance = loadServlet();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">                            (sm.getString(<span class="string">&quot;standardWrapper.allocate&quot;</span>), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!singleThreadModel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug &gt;= <span class="number">2</span>)</span><br><span class="line">                log(<span class="string">&quot;  Returning non-STM instance&quot;</span>);</span><br><span class="line">            countAllocated++;</span><br><span class="line">            <span class="keyword">return</span> (instance);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (instancePool) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (countAllocated &gt;= nInstances) &#123;</span><br><span class="line">            <span class="comment">// Allocate a new instance if possible, or else wait</span></span><br><span class="line">            <span class="keyword">if</span> (nInstances &lt; maxInstances) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instancePool.push(loadServlet());</span><br><span class="line">                    nInstances++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException</span><br><span class="line">                        (sm.getString(<span class="string">&quot;standardWrapper.allocate&quot;</span>), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instancePool.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (debug &gt;= <span class="number">2</span>)</span><br><span class="line">            log(<span class="string">&quot;  Returning allocated STM instance&quot;</span>);</span><br><span class="line">        countAllocated++;</span><br><span class="line">        <span class="keyword">return</span> (Servlet) instancePool.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StandardWrapperValve"><a href="#StandardWrapperValve" class="headerlink" title="StandardWrapperValve"></a>StandardWrapperValve</h2><p>StandardWrapperValve 是 StandardWrapper 的默认的 valve 实现，这个设置在 StandardWrapper 的构造函数中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StandardWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    pipeline.setBasic(<span class="keyword">new</span> StandardWrapperValve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要干两件事</p>
<ul>
<li>执行 servlet 相关的所有 filters</li>
<li>调用 sender 的 service 方法</li>
</ul>
<p>在这个 valve 的 invoke 中具体做了如下事情</p>
<ul>
<li>调用 StandardWrapper 的 allocate 方法，拿到 servlet 的实例</li>
<li>调用 createFilterChain 创建 filter chain</li>
<li>调用 chain 的 doFilter 方法，过程中会调用 servlet 的 service 方法</li>
<li>释放 filter chain</li>
<li>调用 wrapper 的 deallocate 方法</li>
<li>如果 servlet 永远不可用了，调用 wrapper 的 unload 方法</li>
</ul>
<h2 id="FilterDef"><a href="#FilterDef" class="headerlink" title="FilterDef"></a>FilterDef</h2><p>org.apache.catalina.deploy.FilterDef 表示配置文件中的 filter 定义，他的每一个 property 都代表文件中该元素的一个可配置项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDef</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String description = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">    <span class="keyword">private</span> String displayName = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">    <span class="keyword">private</span> String filterClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ApplicationFilterConfig"><a href="#ApplicationFilterConfig" class="headerlink" title="ApplicationFilterConfig"></a>ApplicationFilterConfig</h2><p>org.apache.catalina.core.ApplicationFilterConfig 实现了 javax.servlet.FilterConfig 接口，管理 web application 启动时创建的  filter 实例。构造函数如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ApplicationFilterConfig</span><span class="params">(Context context, FilterDef filterDef)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassCastException, ClassNotFoundException, IllegalAccessException, InstantiationException, ServletException </span>&#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>context 代表 web application, FilterDef 代表 filter 的定义。他有一个 getFilter() 方法可以返回 javax.servlet.Filter 对象实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Filter <span class="title">getFilter</span><span class="params">()</span> <span class="keyword">throws</span> ClassCastException, ClassNotFoundException,</span></span><br><span class="line"><span class="function">    IllegalAccessException, InstantiationException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the existing filter instance, if any</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.filter != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.filter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the class loader we will be using</span></span><br><span class="line">    String filterClass = filterDef.getFilterClass();</span><br><span class="line">    ClassLoader classLoader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (filterClass.startsWith(<span class="string">&quot;org.apache.catalina.&quot;</span>))</span><br><span class="line">        classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        classLoader = context.getLoader().getClassLoader();</span><br><span class="line"></span><br><span class="line">    ClassLoader oldCtxClassLoader =</span><br><span class="line">        Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate a new instance of this filter and return it</span></span><br><span class="line">    Class clazz = classLoader.loadClass(filterClass);</span><br><span class="line">    <span class="keyword">this</span>.filter = (Filter) clazz.newInstance();</span><br><span class="line">    filter.init(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.filter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ApplicationFilterChain"><a href="#ApplicationFilterChain" class="headerlink" title="ApplicationFilterChain"></a>ApplicationFilterChain</h2><p>org.apache.catalina.core.ApplicationFilterChain class 实现了 javax.servlet.FilterChain 接口，StandardWrapperValve 创建这个 chain 的实例并调用 doFilter 方法，doFilter 签名如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br></pre></td></tr></table></figure>

<p>原理和 Valve 一致也用了 责任链 模式，下面是一个实现的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">    FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123; </span><br><span class="line">    <span class="comment">// do something here </span></span><br><span class="line">    ... </span><br><span class="line">    chain.doFilter(request, response); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="The-Application"><a href="#The-Application" class="headerlink" title="The Application"></a>The Application</h2><p>和之前的章节基本一致，最大的区别是在 Bootstrap 中使用了默认的 StandardWrapper 作为 wrapper 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Wrapper wrapper1 = <span class="keyword">new</span> StandardWrapper();</span><br><span class="line">wrapper1.setName(<span class="string">&quot;Primitive&quot;</span>);</span><br><span class="line">wrapper1.setServletClass(<span class="string">&quot;PrimitiveServlet&quot;</span>);</span><br><span class="line">Wrapper wrapper2 = <span class="keyword">new</span> StandardWrapper();</span><br><span class="line">wrapper2.setName(<span class="string">&quot;Modern&quot;</span>);</span><br><span class="line">wrapper2.setServletClass(<span class="string">&quot;ModernServlet&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h2><p>setup 项目之后，访问 URL，抛异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">StandardWrapperValve[Primitive]: Allocate exception for servlet Primitive</span><br><span class="line">javax.servlet.ServletException: Error allocating a servlet instance</span><br><span class="line">javax.servlet.ServletException: Error allocating a servlet instance</span><br><span class="line">    at org.apache.catalina.core.StandardWrapper.allocate(StandardWrapper.java:654)</span><br><span class="line">    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:137)</span><br><span class="line">    at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:642)</span><br><span class="line">    at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:479)</span><br><span class="line">    at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:993)</span><br><span class="line">    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:185)</span><br><span class="line">    at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:642)</span><br><span class="line">    at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:479)</span><br><span class="line">    at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:993)</span><br><span class="line">    at org.apache.catalina.core.StandardContext.invoke(StandardContext.java:2377)</span><br><span class="line">    at org.apache.catalina.connector.http.HttpProcessor.process(HttpProcessor.java:972)</span><br><span class="line">    at org.apache.catalina.connector.http.HttpProcessor.run(HttpProcessor.java:1085)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>可以将 StandardWrapper 的 loadServlet() 中 SystemLogHandler 相关的方法注释掉即可。这个应该是 log 相关的操作，功能上没什么影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    SystemLogHandler.startCapture();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// &#125; finally &#123;</span></span><br><span class="line">    String log = SystemLogHandler.stopCapture();</span><br><span class="line">    <span class="keyword">if</span> (log != <span class="keyword">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getServletContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getServletContext().log(log);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.println(log);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>最后 Chain 相关的章节，在返回 chain 实例的时候用的是 servlet 包下 filter 的实例，这部分配合的部分可以深入探究一下</p>
<p>Filter Vs Valve: 在 tomcat 中效果是一样的，但是 Filter 更像是一个行业标准，Jetty 中也可以用，Valve 更像是一个 Tomcat 实现，其他框架中是没有的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jack-zheng.github.io/hexo/hexo/2021/09/13/HTW-ex10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/jack.jpg">
      <meta itemprop="name" content="Jack Zheng">
      <meta itemprop="description" content="我是张江搬砖小码农, 知识搬运工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackpot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/09/13/HTW-ex10/" class="post-title-link" itemprop="url">Ex10 安全</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 16:42:16" itemprop="dateCreated datePublished" datetime="2021-09-13T16:42:16+08:00">2021-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-14 10:41:39" itemprop="dateModified" datetime="2021-10-14T10:41:39+08:00">2021-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>Chapter 10</strong> covers web application security constraints for restricting access to certain contents. You will learn entities related to security such as principals, roles, login config, authenticators, etc. You will also write two applications that install an authenticator valve in the StandardContext object and uses basic authentication to authenticate users.</p>
</blockquote>
<p>主体和之前的一样，新加的内容是安全相关的东西，更具体来说，是授权相关。可以根据配置的账户密码信息限制用户访问。这个功能现在应该挺鸡肋了，因为一般的 App 都是将这部分功能坐在内部的 login service 中的，哪里会通过这种方式作授权啊，除非买现成的但是不提供授权服务，这也太蠢了吧。。。</p>
<p>问题：Bootstrap2 中貌似做了一次授权之后，会将信息 cache 起来，看看它是存在哪里的</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>有些网站服务需要有访问限制，Tomcat 可以通过配置文件达到这种效果，访问页面时只有输入正确的用户名密码之后才能访问。</p>
<p>Tomcat 有一个 authenticator valve 可以用来做授权，他在系统启动后加入 context 的 pipeline 中，他会在 wrapper valve 之前被调用，做用户验证。</p>
<h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h2><p>Tomcat 中 realm 模块可以做用户验证。一个 context 只能有一个 realm 服务，我们可以通过 context 的 setRealm() 方法设置它。</p>
<p>Realm 中用户信息存放的地址由配置决定，默认情况下，Tomcat 会拿 conf/tomcat-users.xml 中的用户信息做比对。当然我们也可以配置其他数据源，比如 DB。</p>
<p>Catalina 中使用 org.apache.catalina.Realm 这个接口表示这个概念，核心就那四个授权方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Realm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">authenticate</span><span class="params">(String username, String credentials)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">authenticate</span><span class="params">(String username, <span class="keyword">byte</span>[] credentials)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">authenticate</span><span class="params">(String username, String digest,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String nonce, String nc, String cnonce,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String qop, String realm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String md5a2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">authenticate</span><span class="params">(X509Certificate certs[])</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时这个接口还包含 <code>public boolean hasRole(Principal principal, String role);</code> 方法。这个接口有一个抽象实现 org.apache.catalina.realm.RealmBase 还有几个具体实现都在同一个包下：JDBCRealm, JNDIRealm, MemoryRealm, and UserDatabaseRealm。默认使用的是 MemoryRealm，当 server 启动时，他会读取 tomcat-users.xml。</p>
<h2 id="GenericPrincipal"><a href="#GenericPrincipal" class="headerlink" title="GenericPrincipal"></a>GenericPrincipal</h2><p>java.security.Principal 代表 Principal 这个概念，具体实现为 org.apache.catalina.realm.GenericPrincipal。GenericPrincipal 必须关联一个 realm, 构造函数如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericPrincipal</span><span class="params">(Realm realm, String name, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(realm, name, password, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericPrincipal</span><span class="params">(Realm realm, String name, String password, List roles)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.realm = realm;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">    <span class="keyword">if</span> (roles != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.roles = <span class="keyword">new</span> String[roles.size()];</span><br><span class="line">        <span class="keyword">this</span>.roles = (String[]) roles.toArray(<span class="keyword">this</span>.roles);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.roles.length &gt; <span class="number">0</span>)</span><br><span class="line">            Arrays.sort(<span class="keyword">this</span>.roles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Principal 中也包含 <code>hasRole()</code> 方法，你可以传入 <code>*</code> 作为参数检测是否包含任意 role 的意思。</p>
<h2 id="LoginConfig"><a href="#LoginConfig" class="headerlink" title="LoginConfig"></a>LoginConfig</h2><p>login config 包含 realm name 由 org.apache.catalina.deploy.LoginConfig 这个 final class 表示. LoginConfig 包含 realm 和 authentication 的信息，auth name 必须是 BASIC, DIGEST, FORM, or CLIENT-CERT。</p>
<p>当服务器启动的时候，Tomcat 会读取 web.xml 信息，如果 xml 包含 login-config 元素，tomcat 就会创建一个 LoginConfig 对象并为他设置属性。authentication valve 会调用 LoginConfig 的 getRealmName() 方法并传送给浏览器的登陆界面。</p>
<h2 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h2><p>org.apache.catalina.Authenticator 是 authenticator 的表现类，他没有任何方法，只是一个壳子。有一个抽象的实现类 org.apache.catalina.authenticator.AuthenticatorBase，它还集策划给你了 ValveBase 表明它是一个 valve。具体的实现类由 BasicAuthenticator, FormAuthenticator, DigestAuthentication 和 SSLAuthenticator。如果没有具体指明 authentication 类型，则会默认使用 NonLoginAuthenticator。它表示只检测安全限制而不需要授权。</p>
<img  src=http://www.plantuml.com/plantuml/svg/ZOx12i8m44Jl-OhyGFe5lIZYgUWXu4KyBEcQBiGD9D5JFrvff3IjGcx3p9lP9KuOxc1GNi2zK1W7CMQzXuY2vdptJ0Do8WF91o4cHBPZqopeMKbr7QZlaM_hNZwWYQr3JPRF_BKARbfRpBMZKcLfbMtRXPCV_N5YO-MvZo9JVlw7rBghueu-FAh00rcCgGezUUwy9IxYDm00>

<h2 id="Installing-the-Authenticator-Valve"><a href="#Installing-the-Authenticator-Valve" class="headerlink" title="Installing the Authenticator Valve"></a>Installing the Authenticator Valve</h2><p>login-config element 在 deployment 文件中只能出现一次，其中包含有 auth-method 元素。这意味着 context 中只能有一个 LoginConfig 实例并且只能有一个 authentication class 实现。</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Impl</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BASIC</td>
<td align="left">BasicAuthenticator</td>
</tr>
<tr>
<td align="left">FORM</td>
<td align="left">FormAuthenticator</td>
</tr>
<tr>
<td align="left">DIGEST</td>
<td align="left">DigestAuthenticator</td>
</tr>
<tr>
<td align="left">CLIENT-CERT</td>
<td align="left">SSLAuthenticator</td>
</tr>
</tbody></table>
<p>如果 auth-method 没有设置，就表示使用的是 NonLoginAuthenticator。org.apache.catalina.startup.ContextConfig 是 Context 的配置类，包含 authentication 信息。下面的例子中，我们使用 SimpleContextConfig 动态加载 BasicAuthenticator 作为 StandardContext 的配置项。</p>
<h2 id="The-Applications"><a href="#The-Applications" class="headerlink" title="The Applications"></a>The Applications</h2><h3 id="Bootsrap1"><a href="#Bootsrap1" class="headerlink" title="Bootsrap1"></a>Bootsrap1</h3><p>第一个例子，没有使用配置文件，而是直接在 Bootstrap 类中做了设置。新建了一个 SimpleContextConfig，它是一个 Listener，添加到 context 的监听器列表中，当 context start 时，接受到 event 并配置 context</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bootstrap1 中代码如下</span></span><br><span class="line">LifecycleListener listener = <span class="keyword">new</span> SimpleContextConfig();</span><br><span class="line">((Lifecycle) context).addLifecycleListener(listener);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">((Lifecycle) context).start();</span><br></pre></td></tr></table></figure>

<p>实现如下,  context start 后，event 触发，在 listener 中拿到对应的 context，并进行 auth 相关的设置，内容包括</p>
<ul>
<li>设置 login config</li>
<li>设置 authenticator 到 context 的 pipeline</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleContextConfig</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Lifecycle.START_EVENT.equals(event.getType())) &#123;</span><br><span class="line">            context = (Context) event.getLifecycle();</span><br><span class="line">            authenticatorConfig();</span><br><span class="line">            context.setConfigured(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">authenticatorConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Does this Context require an Authenticator?</span></span><br><span class="line">        SecurityConstraint constraints[] = context.findConstraints();</span><br><span class="line">        <span class="keyword">if</span> ((constraints == <span class="keyword">null</span>) || (constraints.length == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LoginConfig loginConfig = context.getLoginConfig();</span><br><span class="line">        <span class="keyword">if</span> (loginConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">            loginConfig = <span class="keyword">new</span> LoginConfig(<span class="string">&quot;NONE&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            context.setLoginConfig(loginConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Has an authenticator been configured already?</span></span><br><span class="line">        Pipeline pipeline = ((StandardContext) context).getPipeline();</span><br><span class="line">        <span class="keyword">if</span> (pipeline != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Valve basic = pipeline.getBasic();</span><br><span class="line">            <span class="keyword">if</span> ((basic != <span class="keyword">null</span>) &amp;&amp; (basic <span class="keyword">instanceof</span> Authenticator))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            Valve valves[] = pipeline.getValves();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valves.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (valves[i] <span class="keyword">instanceof</span> Authenticator)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// no Pipeline, cannot install authenticator valve</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Has a Realm been configured for us to authenticate against?</span></span><br><span class="line">        <span class="keyword">if</span> (context.getRealm() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Identify the class name of the Valve we should configure</span></span><br><span class="line">        String authenticatorName = <span class="string">&quot;org.apache.catalina.authenticator.BasicAuthenticator&quot;</span>;</span><br><span class="line">        <span class="comment">// Instantiate and install an Authenticator of the requested class</span></span><br><span class="line">        Valve authenticator = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class authenticatorClass = Class.forName(authenticatorName);</span><br><span class="line">            authenticator = (Valve) authenticatorClass.newInstance();</span><br><span class="line">            ((StandardContext) context).addValve(authenticator);</span><br><span class="line">            System.out.println(<span class="string">&quot;Added authenticator valve to Context&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在 Bootstrap1 中设置 security constraint 相关的配置. 这里指定了 constraint 中只有 role 是 manager 的可以访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add constraint</span></span><br><span class="line">SecurityCollection securityCollection = <span class="keyword">new</span> SecurityCollection();</span><br><span class="line">securityCollection.addPattern(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">securityCollection.addMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line"></span><br><span class="line">SecurityConstraint constraint = <span class="keyword">new</span> SecurityConstraint();</span><br><span class="line">constraint.addCollection(securityCollection);</span><br><span class="line">constraint.addAuthRole(<span class="string">&quot;manager&quot;</span>);</span><br><span class="line">LoginConfig loginConfig = <span class="keyword">new</span> LoginConfig();</span><br><span class="line">loginConfig.setRealmName(<span class="string">&quot;Simple Realm&quot;</span>);</span><br><span class="line"><span class="comment">// add realm</span></span><br><span class="line">Realm realm = <span class="keyword">new</span> SimpleRealm();</span><br><span class="line"></span><br><span class="line">context.setRealm(realm);</span><br><span class="line">context.addConstraint(constraint);</span><br><span class="line">context.setLoginConfig(loginConfig);</span><br></pre></td></tr></table></figure>

<p>SimpleRealm 实现如下, 它其实就是模拟了一个内存中的 DB，当开启 security constrain 后，通过 GET 访问页面就会跳出验证弹窗。输入账户信息，就会调用到下面 authenticate() 方法中做判断了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRealm</span> <span class="keyword">implements</span> <span class="title">Realm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        createUserDatabase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Container container;</span><br><span class="line">    <span class="keyword">private</span> ArrayList users = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContainer</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A simple Realm implementation&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">authenticate</span><span class="params">(String username, String credentials)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SimpleRealm.authenticate()&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (username == <span class="keyword">null</span> || credentials == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        User user = getUser(username, credentials);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericPrincipal(<span class="keyword">this</span>, user.username, user.password, user.getRoles());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">authenticate</span><span class="params">(String username, <span class="keyword">byte</span>[] credentials)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">authenticate</span><span class="params">(String username, String digest, String nonce,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String nc, String cnonce, String qop, String realm, String md5a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">authenticate</span><span class="params">(X509Certificate certs[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasRole</span><span class="params">(Principal principal, String role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((principal == <span class="keyword">null</span>) || (role == <span class="keyword">null</span>) ||</span><br><span class="line">                !(principal <span class="keyword">instanceof</span> GenericPrincipal))</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">        GenericPrincipal gp = (GenericPrincipal) principal;</span><br><span class="line">        <span class="keyword">if</span> (!(gp.getRealm() == <span class="keyword">this</span>))</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">boolean</span> result = gp.hasRole(role);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removePropertyChangeListener</span><span class="params">(PropertyChangeListener listener)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> User <span class="title">getUser</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        Iterator iterator = users.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            User user = (User) iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (user.username.equals(username) &amp;&amp; user.password.equals(password))</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createUserDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="string">&quot;ken&quot;</span>, <span class="string">&quot;blackcomb&quot;</span>);</span><br><span class="line">        user1.addRole(<span class="string">&quot;manager&quot;</span>);</span><br><span class="line">        user1.addRole(<span class="string">&quot;programmer&quot;</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="string">&quot;cindy&quot;</span>, <span class="string">&quot;bamboo&quot;</span>);</span><br><span class="line">        user2.addRole(<span class="string">&quot;programmer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        users.add(user1);</span><br><span class="line">        users.add(user2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String username;</span><br><span class="line">        <span class="keyword">public</span> ArrayList roles = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">public</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRole</span><span class="params">(String role)</span> </span>&#123;</span><br><span class="line">            roles.add(role);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ArrayList <span class="title">getRoles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> roles;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务器，当我们用 role 是 manager 的 user 去访问，页面显示正常，当我们用 programer 去访问，页面不显示</p>
<p>流程大致描述如下</p>
<ol>
<li>启动 server 加载配置</li>
<li>访问页面</li>
<li>context 调用 pipeline</li>
<li>pipeline 调用 valve</li>
<li>调用 BasicAuthenticator 的 auth 方法验证 - 在 listener 中指定</li>
</ol>
<h2 id="Bootstrap2"><a href="#Bootstrap2" class="headerlink" title="Bootstrap2"></a>Bootstrap2</h2><p>第二个例子和第一个例子很想，唯一区别就是将 Realm 的配置指定到了 tomcat-users.xml 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add realm</span></span><br><span class="line">Realm realm = <span class="keyword">new</span> SimpleUserDatabaseRealm();</span><br><span class="line">((SimpleUserDatabaseRealm) realm).createDatabase(<span class="string">&quot;conf/tomcat-users.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>SimpleUserDatabaseRealm 实现如下, 里面一个比较有意思的点是 MemoryUserDatabase 这个类，它会默认加载 conf/tomcat-users.xml 的内容，解析出来，格式是 hard code 的，挺有意思。逻辑和之前的基本一样，没什么新鲜的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleUserDatabaseRealm</span> <span class="keyword">extends</span> <span class="title">RealmBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> UserDatabase database = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">&quot;SimpleUserDatabaseRealm&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String resourceName = <span class="string">&quot;UserDatabase&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Principal <span class="title">authenticate</span><span class="params">(String username, String credentials)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Does a user with this username exist?</span></span><br><span class="line">        User user = database.findUser(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do the credentials specified by the user match?</span></span><br><span class="line">        <span class="comment">// FIXME - Update all realms to support encoded passwords</span></span><br><span class="line">        <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (hasMessageDigest()) &#123;</span><br><span class="line">            <span class="comment">// Hex hashes should be compared case-insensitive</span></span><br><span class="line">            validated = (digest(credentials).equalsIgnoreCase(user.getPassword()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            validated = (digest(credentials).equals(user.getPassword()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!validated) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList combined = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Iterator roles = user.getRoles();</span><br><span class="line">        <span class="keyword">while</span> (roles.hasNext()) &#123;</span><br><span class="line">            Role role = (Role) roles.next();</span><br><span class="line">            String rolename = role.getRolename();</span><br><span class="line">            <span class="keyword">if</span> (!combined.contains(rolename)) &#123;</span><br><span class="line">                combined.add(rolename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator groups = user.getGroups();</span><br><span class="line">        <span class="keyword">while</span> (groups.hasNext()) &#123;</span><br><span class="line">            Group group = (Group) groups.next();</span><br><span class="line">            roles = group.getRoles();</span><br><span class="line">            <span class="keyword">while</span> (roles.hasNext()) &#123;</span><br><span class="line">                Role role = (Role) roles.next();</span><br><span class="line">                String rolename = role.getRolename();</span><br><span class="line">                <span class="keyword">if</span> (!combined.contains(rolename)) &#123;</span><br><span class="line">                    combined.add(rolename);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> GenericPrincipal(<span class="keyword">this</span>, user.getUsername(),</span><br><span class="line">                user.getPassword(), combined));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------ Lifecycle Methods</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prepare for active use of the public methods of this Component.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Principal <span class="title">getPrincipal</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getPassword</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDatabase</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        database = <span class="keyword">new</span> MemoryUserDatabase(name);</span><br><span class="line">        ((MemoryUserDatabase) database).setPathname(path);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            database.open();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)  &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jack-zheng.github.io/hexo/hexo/2021/09/10/HTW-ex09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/jack.jpg">
      <meta itemprop="name" content="Jack Zheng">
      <meta itemprop="description" content="我是张江搬砖小码农, 知识搬运工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackpot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/09/10/HTW-ex09/" class="post-title-link" itemprop="url">Ex09 Session 管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-10 17:48:20" itemprop="dateCreated datePublished" datetime="2021-09-10T17:48:20+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-14 10:41:39" itemprop="dateModified" datetime="2021-10-14T10:41:39+08:00">2021-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/Tomcat/" itemprop="url" rel="index">
                    <span itemprop="name">Tomcat</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>505</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><strong>Chapter 9</strong> discusses the manager, the component that manages sessions in session management. It explains the various types of managers and how a manager can persist session objects into a store. At the end of the chapter, you will learn how to build an application that uses a StandardManager instance to run a servlet that uses session objects to store values. </p>
</blockquote>
<p>PS: 本节实验失败了，页面显示不出来，追踪了一下，servlet 可以正常加载，但是执行 init() 方法的时候报错了。感觉可以先用之前的 javaweb 项目把这个页面显示出来，在看看问题。有可能是依赖有问题。</p>
<p>主要知识点</p>
<ul>
<li>Session 相关的接口关系</li>
<li>通过 Manager 管理 session</li>
<li>实现了 Lifecycle 接口</li>
<li>提供 swap out 功能，节省内存资源 - 长时间不用的 session 暂存</li>
<li>持久化</li>
</ul>
<p>没什么成就感，暂时先记怎么多把</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jack-zheng.github.io/hexo/hexo/2021/09/10/JVM-c9-class-loader-and-sub-system-execution-samples/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/jack.jpg">
      <meta itemprop="name" content="Jack Zheng">
      <meta itemprop="description" content="我是张江搬砖小码农, 知识搬运工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackpot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/09/10/JVM-c9-class-loader-and-sub-system-execution-samples/" class="post-title-link" itemprop="url">JVM c9 class loader and sub system execution samples</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-10 10:32:15" itemprop="dateCreated datePublished" datetime="2021-09-10T10:32:15+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-14 10:41:39" itemprop="dateModified" datetime="2021-10-14T10:41:39+08:00">2021-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>代码编译的结果从本地机器码转为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>在 Class 文件格式与执行引擎这部分里，用户的程序能直接参与的内容并不多，Class 以何种格式存储，类型和施加在，如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变。能操作的，主要是字节码生成与类加载两个部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏借鉴的思路，这些思路后来成为很多常用功能和程序实现的基础。</p>
<h2 id="9-2-案例分析"><a href="#9-2-案例分析" class="headerlink" title="9.2 案例分析"></a>9.2 案例分析</h2><p>四个案例，关于类加载和字节码各两个。</p>
<h3 id="9-2-1-Tomcat-正统的类加载架构"><a href="#9-2-1-Tomcat-正统的类加载架构" class="headerlink" title="9.2.1 Tomcat: 正统的类加载架构"></a>9.2.1 Tomcat: 正统的类加载架构</h3><p>主流的 Java Web 服务器，如 Tomcat, Jetty 等都实现了自己定义的类加载器，而且还不止一个。因为一个功能健全的 Web 服务器，都要解决如下这些问题：</p>
<ul>
<li>部署在同一个服务器上的两个 web 应用程序所使用的 Java 类库可以实现互相隔离。两个不同应用可能依赖同一个第三方类库的不同版本，不能要求每个类库在一个服务器中只能有一份，服务器应该能够保证两个独立应用程序的类库可以互相独立使用。</li>
<li>部署在同一个服务器上的两个 web 应用所使用的 Java 类库可以互相共享。与前一个相反，但很常见，如用户可能有 10 个使用 Spring 的应用部署在统一台服务器，如果把 10 份 Spring 分别存在应用的隔离目录，将会很大的浪费资源。磁盘空间是其次，主要是良妃内存，很容易造成方法去过度膨胀的风险。</li>
<li>服务器需要尽可能保证自身的安全不受部署的 Web 应用程序的影响。一般来说，给予安全考虑，服务器所使用的类库应该与程序类库相互独立。</li>
<li>只是 JSP 应用的 Web 服务器，十有八九都需要支持 HotSwap 功能。JSP 由于其纯文本特性，修改几率远大于第三方类库和自己的 Class 文件。ASP，PHP 和 JSP 这些网页应用也将修改后无需重启作为优势来看待，因此，主流 Web 服务器都会支持 JSP 生成类的热替换。</li>
</ul>
<p>由于以上问题，不是 web 应用时，单独一个 ClassPath 就不能满足要求了，所以各种 web 服务器不约而同的提供了好几个不同还以的 ClassPath 路径供用户存放第三方类库。一般这些路径都以 lib 或 classes 命名。不同路径中的类库，具备不同的访问范围和服务对象，通常每个目录都会对应一个自定义类加载器去加载防止在里面的 Java 类库。下面以 Tomcat 为例，分析其规划。</p>
<p>Tomcat 目录结构中，有三组目录可以设置，一组默认，供4组。分别是</p>
<ul>
<li>/common 目录，类库可被 Tomcat 和所有 Web 应用共同使用</li>
<li>/server 目录，类库可被 Tomcat 使用，对所有 Web 应用不可见</li>
<li>/shared 目录，类库可以被所有 Web 应用共同使用，对 Tomcat 不可见</li>
<li>/WebApp/WEB-INF 目录，仅被该 Web 应用使用，对 Tomcat 和其他应用不可见</li>
</ul>
<img  src=http://www.plantuml.com/plantuml/svg/bPAnJiCm54LtVuKbvl81b0Kg5iG64WDYU8cVH91ZH_53z0Ew40c9eGmWLC5M9jI50TJFSS9du2HE98imPFEzyRt7yJCb996VwJG6Ab_kRV5cdzRLywBQVDlYzMUxBLUVvMh1cD82UHHBVi7imuSjrlqE5s27MfEX738-as0CFz4WC6UNFeTDhhnxjvl787Sq9rGcqMeu1otlQrajGzv1bid47VdVPEoIE-3sO2HlS2eJXNlzQbTe8XHJmZarheFCT9fg5K1QgwdlsdbN3-JA5Ooc-5p8yURmdvYnZDCho544XDOQxh_52B9iBEGS8pU30D9Qmv1hCvfmRC9wfp7_qrw_oFt9f7vX3FtQJOKny2AkHTo9VcozPUhlnelkBbX_ARNR7FuN>

<p>实线节点是 JDK 自带加载起，虚线是 Tomcat 自建的加载器。Common类加载器，Catalina类加载器(也称为Server类加载器)，Shared类加载器和Webapp类加载器则是 Tomcat 自定义的类加载器，分别加载 /common/<em>, /server/</em>, shared/* 和 /WebApp/WEB-INF/* 中的 Java 类库。WebApp 类加载器和 JSP 类加载器通常还会有多个实例，每个 Web 应用对应一个 WebApp 类加载器，每个 JSP 文件对应一个 JasperLoader 类加载器。</p>
<p>从图可以看出，Common 类加载器能加载的类都可以被 Catalina 类加载器和 Shared 类加载器使用，而 Catalina 类加载器和 Shared 类加载器自己能加载的类则与对方相互隔离。WebApp类加载器可以使用Shared类加载器加载到的类，但各个WebApp类加载器实例之间相互隔离。而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class文件，它存在的目的就是为了被丢弃：当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的JSP类加载器来实现JSP文件的HotSwap功能。</p>
<p>上面讲的是 Tomcat6 之前的加载器架构，Tomcat6 之后对默认的目录结构做了简化，只有指定 tomcat/conf/catalina.properties 的 server.loader 和 share.loader 后才会真正建立 Catalina类加载器和Shared类加载器实例，否则用到的地方都会用 Common 类加载器实例代替，而默认的配置文件中没有设置这两项，所以 Tomcat6 之后顺理成章的把 /common, /server 和 /shared 三个目录合并在一起变成 /lib 目录，相当于之前的 /common 目录的作用，是 Tomcat 团队简化部署的一项改动。</p>
<h3 id="9-2-2-OSGi：灵活的类加载器架构"><a href="#9-2-2-OSGi：灵活的类加载器架构" class="headerlink" title="9.2.2 OSGi：灵活的类加载器架构"></a>9.2.2 OSGi：灵活的类加载器架构</h3><p>没兴趣，用到再看</p>
<h3 id="9-2-3-字节码生成技术与动态代理的实现"><a href="#9-2-3-字节码生成技术与动态代理的实现" class="headerlink" title="9.2.3 字节码生成技术与动态代理的实现"></a>9.2.3 字节码生成技术与动态代理的实现</h3><p>有兴趣，等 Tomcat 完结了再看，不过应该要先看完第八章的内容才行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jack-zheng.github.io/hexo/hexo/2021/09/03/JVM-c7-class-loader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/jack.jpg">
      <meta itemprop="name" content="Jack Zheng">
      <meta itemprop="description" content="我是张江搬砖小码农, 知识搬运工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackpot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/09/03/JVM-c7-class-loader/" class="post-title-link" itemprop="url">虚拟机类加载机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-03 18:50:36" itemprop="dateCreated datePublished" datetime="2021-09-03T18:50:36+08:00">2021-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-14 10:41:39" itemprop="dateModified" datetime="2021-10-14T10:41:39+08:00">2021-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p>Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制。</p>
<h2 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h2><p>一个类从被加载到虚拟机内存中，到卸载为止，会经历七个步骤</p>
<ul>
<li>加载 Loading</li>
<li>验证 Verification</li>
<li>准备 Preparation</li>
<li>解析 Resolution</li>
<li>初始化 Initialization</li>
<li>使用 Using</li>
<li>写在 Unloading</li>
</ul>
<p>验证，准备，解析三部分统称为 链接 Linking</p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析不一定，有些情况下可以在初始化后再开始，为了支持动态绑定</p>
<p>有且只有六种情况必须立即对类进行初始化</p>
<ol>
<li>遇到 new, getstatic, putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先出发其初始化阶段。能够生产这四条指令的典型 Java 代码场景有：<ul>
<li>使用 new 关键字实例化对象的时候</li>
<li>读取或设置一个类型的静态字段(被 final 修饰，已在编译期把结果放入常量池的静态字段除外)</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li>
</ol>
<p>除此之外，所有引用类型的方式都不会出发初始化，称为被动引用。下面是三个被动引用的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SuperClass init!</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>只会输出 “SuperClass init!”，而不会输出 “SubClass init!”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过数组定义来引用类，不会出发此类的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况并不会触发类的初始化，只会触发 “[Lclassloading.SuperClass” 的类初始化节点，它是虚拟机自动生成的，创建动作由 newarray 触发，代表一维数组。</p>
<p>第三个例子，对应第一条中的第二点，final 修饰的常量编译阶段通过常量传播优化，将值存入 NotInitialization03 类的常量池中，后面对 ConstClass.HELLOWORLD 的引用世纪都被转为 NotInitialization03 对自身常量池的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="7-3-类加载的过程"><a href="#7-3-类加载的过程" class="headerlink" title="7.3 类加载的过程"></a>7.3 类加载的过程</h2><p>下面具体介绍 加载，验证，准备，解析和初始化这五个阶段所执行的具体动作。</p>
<h2 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h2><p>加载是 类加载 的第一个阶段，会做三件事</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>再内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>PS: 对数组类型的加载，这里还有一些描述，以后有用到再看</p>
<h3 id="7-3-1-验证"><a href="#7-3-1-验证" class="headerlink" title="7.3.1 验证"></a>7.3.1 验证</h3><p>验证是链接阶段第一步，目的是确保 Class 文件的字节流中包含的信息符合 Java 虚拟机规范 的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>验证阶段非常重要，这个阶段是否严谨直接决定虚拟机能否承受恶意代码的攻击。从代码量和耗费的执行性能角度讲，验证阶段工作量再虚拟机类加载过程中占了相当大的比重。</p>
<p>验证阶段大致会完成下面四个阶段的检测动作：文件格式验证，元数据验证，字节码验证和符号引用验证</p>
<p><strong>文件格式验证</strong></p>
<p>第一阶段要验证字节流是否符合 Class 文件格式规范，验证点包括</p>
<ul>
<li>是否以魔数 0xCAFEBABE 开头</li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型(检查常量tag标志)</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
<li>…</li>
</ul>
<p>以上只列举了一部分</p>
<p><strong>元数据验证</strong></p>
<p>第二阶段是对字节码描述的信息进行语义分析，保证其描述的信息符合规范</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等</li>
<li>…</li>
</ul>
<p><strong>字节码验证</strong></p>
<p>第三阶段是这个那个验证过程中最复杂的一个阶段，通过数据流分析和控制流分析，确定程序予以是合法的，符合逻辑的。</p>
<p><strong>符号引用验证</strong></p>
<p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在链接的第三个阶段-解析阶段发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要校验下列内容</p>
<h3 id="7-3-2-准备"><a href="#7-3-2-准备" class="headerlink" title="7.3.2 准备"></a>7.3.2 准备</h3><p>准备阶段是正式为类中定义的变量(即静态变量，被 static 修饰的变量)分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应该再方法区中进行分配，但方方法区本身就是一个逻辑上的区域。JDK7 之前 HotSpot 使用永久区，JDK8 之后类变量会和 Class 一起放在堆空间。这点再 4.3.1 验证过了。</p>
<p>准备阶段的赋值仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。其次，这里说的初始值指的是数据类型的零值，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>准备阶段后，初始值为 0 而不是 123，此时尚未执行任何 Java 方法，把 123 赋值给 value 的方法存放在类构造器 <clinit>() 方法之中，所以赋值要到类初始化阶段才会被执行。Java 所有基本数据类型零值表如下</p>
<table>
<thead>
<tr>
<th align="left">data type</th>
<th align="left">value</th>
<th align="left">data type</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">0</td>
<td align="left">boolean</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">0L</td>
<td align="left">float</td>
<td align="left">0.0f</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">(short)0</td>
<td align="left">double</td>
<td align="left">0.0d</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">‘\u0000’</td>
<td align="left">reference</td>
<td align="left">null</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">(byte)0</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>例外情况是前面展示过的 final 的情况，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>编译时 Javac 将会为 value 生成 Constant Value 属性，在准备阶段虚拟机就会根据 Constant Value 的设置将value赋值为123。</p>
<h3 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h3><p>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</li>
</ul>
<p>PS: 中间穿插很多解析类型的解释，暂时用不到，跳过</p>
<h3 id="7-3-5-初始化"><a href="#7-3-5-初始化" class="headerlink" title="7.3.5 初始化"></a>7.3.5 初始化</h3><p>类的初始化阶段是勒加载过程的最后一个步骤，之前介绍的几个动作，除了在加载阶段用户可以通过自定义类加载器的方式局部参与外，其余都由 Java 虚拟机来主导控制。直到初始化阶段，虚拟机才真正执行类中编写的 Java 程序代码，将主导权移交给应用程序。</p>
<p>初始化阶段就是执行类构造器 <clinit>() 方法的过程，它是Javac编译器的自动生成物。</p>
<p><clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块(static{})中的语句合并产生的，顺序由源文件中顺序决定。静态语句块只能访问它之前的变量。之后的变量可以赋值，但是不能访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        System.out.println(i); <span class="comment">// 编译器提示 非法向前引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><clinit>() 不需要显示调用父类构造器，虚拟机会保证在子类 <clinit>() 执行前，父类的 <clinit>() 已经执行完毕，所以 jvm 中第一个被执行的 <clinit>() 肯定是 java.lang.Object.</p>
<p>父类 <clinit>() 优先执行，即父类的静态语句块要优先于子类的变量赋值操作。下面例子中再子类使用变量之前，父类已经完成了静态块的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Sub.B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><clinit>() 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <clinit>() 方法</p>
<p>接口仍有变量初始化赋值操作，也会生成 <clinit>() 方法。但与类不同，执行接口的 <clinit>() 不需要先执行弗雷接口的 <clinit>()。接口的实现类再初始化时也一样不会执行接口的 <clinit>() 方法。</p>
<p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步。如果一个类的 <clinit>() 方法有耗时很长的操作，很可能造成多个进程阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test22</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; init DeadLoopClass&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable scritp = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; start&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; run over&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(scritp);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(scritp);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Thread[Thread-0,5,main] start</span></span><br><span class="line"><span class="comment">// Thread[Thread-1,5,main] start</span></span><br><span class="line"><span class="comment">// Thread[Thread-0,5,main] init DeadLoopClass</span></span><br></pre></td></tr></table></figure>

<h2 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h2><p>虚拟机设计团队有意把类加载阶段中 “通过一个类的全限定名来获取描述该类的二进制字节流” 的这个动作放到 Java 虚拟机外部去实现，以便让程序自己决定如何获取所需的类。实现这个动作的代码被称作-类加载器(Class Loader)。</p>
<p>这项技术原来是为了支持 Java Applet 而设计的，如今，Applet 已经淘汰了，但是类加载器却在 类层次划分，OSGi, 如部署，代码加密等领域大放异彩。</p>
<h3 id="7-4-1-类与类加载器"><a href="#7-4-1-类与类加载器" class="headerlink" title="7.4.1 类与类加载器"></a>7.4.1 类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但他在 Java 程序中起到的作用却远超类加载阶段。任意类，必须由加载他的类加载器和这个类本身共同确立其在 jvm 中的唯一性，俄米格类加载器都拥有一个独立的类名称空间。</p>
<p>通俗讲：比较两个类是否相等，只有在两个类由同一个类加载器加载的前提下才有意义，否则，这两个类逼不想等。</p>
<p>这里所指的“相等”，包括代表类的Class对象的equals()方法，isAssignableFrom()方法、isInstance() 方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况</p>
<p>下面的例子中，我们自定义了一个 class loader 并加载当前测试类，生成实例。拿这个实例和默认类加载器的测试类进行 instanceof 的比较，结果为 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                String fileName = name.substring(name.indexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">&quot;classloading.ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> classloading.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class classloading.ClassLoaderTest</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-2-双亲委派模型"><a href="#7-4-2-双亲委派模型" class="headerlink" title="7.4.2 双亲委派模型"></a>7.4.2 双亲委派模型</h3><p>从虚拟机的角度看，只有两类加载器</p>
<ul>
<li>启动类加载器(Bootstrap Class Loader): C++ 实现，虚拟机的一部分</li>
<li>其他加载器：Java 实现，独立与虚拟机外</li>
</ul>
<p>开发人员角度看，可以分的更细致，可以分为三层类加载器</p>
<ul>
<li>启动类加载器：加载存放在 <JAVA_HOME>\lib 或者 -Xbootstrapclasspth 参数指定的路径下，能被 JVM 识别的类库到内存中。不能被 Java 程序直接使用，编写自定义加载器时，返回 null 即可将加载委托给启动类加载器了</li>
<li>扩展类加载器(Extension Class Loader): 在类 sun.misc.Lanucher$ExtClassLoader 中，负责加载 <JAVA_HOME>\lib\ext 或者 java.ext.dirs 系统变量锁指定的路径中所有的类库。JDK9 之后，被模块化所替代。</li>
<li>应用程序类加载器(Application Class Loader): 由 sun.misc.Lanucher$AppClassLoader 实现。ClassLoader 的 getSystemClassLoader() 方法的返回值。记载用户类路径上所有类库。如果应用程序没有自定义过自己的类加载器，一般这个就是默认的类加载器。</li>
</ul>
<img  src=http://www.plantuml.com/plantuml/svg/AyaioKbLUBvnzzEk1I_sxdqwSyNpMIrF-tkUxDhqTFcKPrlsFLknyEcyRYwklFoKL8Mav1o5QAwd4zO_xLg1h8VBAJ-_fBYaAB50mJadiRXOmIS_CIMrY2iMgYyLhEzPvygd6wUYw7EjA4dDAyxCpyEkBn5YtwufpwUWskTOK92JcPnOWbDdQNAE8L3hY_PLJzVDUhAp4qLtQ75g4KvjHgHf0mM9ZQuko8jSgL0sqDbSN8bG3iWbo1mZ0000>

<p>JDK9 之前的 Java 应用都是由这三类加载器互相配合来完成加载的。双亲委派模型要求，除了顶层的启动类加载器外，其余的类加载器都要有自己的父类加载器。这里的父子关系不是通过继承关系实现的，而是通过使用组合(Composition)关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，首先不会尝试自己去加载这个类，而是委派给父类加载器去完成，每次皆是如此。只有当父类无法实现这个加载请求时，子类才是尝试自己去加载。</p>
<p>使用亲委派模型的好处是具备了一种带有优先级的层次关系。例如 java.lang.Object, 无论那哪个加载器加载它，最终都会使用 rt.jar 下的 Object 定义。如果不用这个模型，用户在 ClassPath 下定义一个 java.lang.Object 类, 系统中就会出现多个不同的 Object 类，Java 类型体系中最基础的行为就无法得到保证了。</p>
<p>下面是 ClassLoader 中加载类的代码实现。先尝试查这个类是否已经被加载。再看是否有父加载器，如果没有则使用启动类加载器加载。如果还是没有找到类，则尝试用自己加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-3-破坏双亲委派模型"><a href="#7-4-3-破坏双亲委派模型" class="headerlink" title="7.4.3 破坏双亲委派模型"></a>7.4.3 破坏双亲委派模型</h3><p>双亲委派模式是推荐方式，而不是强制性约束。直到 JDK9 的模块化为止，主要出现过 3 次较大规模的被破坏情况。</p>
<p>第一次是 JDK1.2 之前，双亲委派模型还没出现，但是类加载器的概念和抽象类已经引入了。</p>
<p>第二次被破坏是由于这个模型自身的缺陷导致的。这个模型很好的解决了各个类加载器协作时基础类型的一致性问题，但程序设计往往没有绝对不变的完美规则，如果基础类型又要调用回用户的代码，该如何。典型的例子便是 JNDI 服务。JDNI 现在已经是 Java 的标准服务，代码由启动类加载器来完成加载(JDK1.3 时加入到 rt.jar)，肯定属于 Java 中很基础的类型了。JNDI 目的是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的 ClassPath 下的 JNDI 服务提供者接口(Service Provider Interface, SPI) 的代码，现在问题来了，启动类加载器是绝不可能认识，加载这些代码的。</p>
<p>为了解决这个困境，Java 设计团队引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader). 这个加载器可以通过 java.lang.Thread 的 setContextClassLoader() 方法进行设置，如果创建线程时未设置，将会从父类线程中继承一个，如果再应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。JNDI 使用这个线程上下文类加载器去加载所需的 SPI 服务代码，这个是一个类加载器去请求子类加载器完成类加载的行为，实际上打通了双亲委派模型的层次结构来逆向使用类加载器，Java 中涉及 SPI 的加载基本都采用这种方式，比如 JNDI，JDBC，JCE，JAXB 和 JBI 等。当 SPI 多于一个时，只能采用硬编码，为了消除这种不雅的实现，JDK6 提供了 java.util.ServiceLoader 配合 META-INF/services 中的配置信息，辅以责任链模式，才算给 SPI 提供了一种相对合理的解决方案。</p>
<p>第三次被破坏是由于用户对程序动态性的追求导致的。典型应用场景有：代码热部署，模块热部署等。即像电脑外设一般，在没有重新启动的情况下完成功能升级。现在比较热门的实现是 IBM 的 OSGi, Oracle 的 Jigsaw 。后面还有一些 OSGi 的介绍，但是没用过，看看就过了，用到再说。</p>
<h3 id="7-5-Java-模块化系统"><a href="#7-5-Java-模块化系统" class="headerlink" title="7.5 Java 模块化系统"></a>7.5 Java 模块化系统</h3><p>pass, 暂时用不到</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jack-zheng.github.io/hexo/hexo/2021/08/17/TIJ4-23-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/jack.jpg">
      <meta itemprop="name" content="Jack Zheng">
      <meta itemprop="description" content="我是张江搬砖小码农, 知识搬运工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackpot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/08/17/TIJ4-23-concurrency/" class="post-title-link" itemprop="url">TIJ4 23 concurrency</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-17 18:59:59" itemprop="dateCreated datePublished" datetime="2021-08-17T18:59:59+08:00">2021-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-14 10:41:39" itemprop="dateModified" datetime="2021-10-14T10:41:39+08:00">2021-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/TIJ4/" itemprop="url" rel="index">
                    <span itemprop="name">TIJ4</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>60k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>55 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="The-manay-faces-of-concurrency"><a href="#The-manay-faces-of-concurrency" class="headerlink" title="The manay faces of concurrency"></a>The manay faces of concurrency</h2><p>并发看上去很让人摸不着头脑，主要是应为我们需要解决多个问题，并且解决问题的方法很多。这两者间也没有明确的匹配关系。所以你必须要全面的理解各种问题和场景才能更高效的使用并发。</p>
<p>使用并发可以解决的问题可以粗略归纳为两类</p>
<h3 id="Faster-execution"><a href="#Faster-execution" class="headerlink" title="Faster execution"></a>Faster execution</h3><p>多处理器系统通过并发可以提高效率，这很容易理解。但是有时但处理器系统通过并发也能提高效率，听上去可能有点反直觉，但是确实如此。一般来说，在但处理器系统中使用多线程，会有上下文切换(context switch)开销导致性能下降。但是如果场景中有较多的 IO 操作，则可能开销不增反降。</p>
<h3 id="Improving-code-design"><a href="#Improving-code-design" class="headerlink" title="Improving code design"></a>Improving code design</h3><p>单核系统中实现多线程，本质上，一个时间点也只能做一件事，理论上，我们可以将这个多线程转化为单线程实现。但是有时多线程可以提供更好的组织方式，比如在模拟动画的场景上。</p>
<p>Java 中多线程是有优先级的。通过这个优先级，JVM 会分配不同的时间片给程序执行。</p>
<h2 id="Basic-threading"><a href="#Basic-threading" class="headerlink" title="Basic threading"></a>Basic threading</h2><p>并发可以帮你讲你的程序分成独立的 task，每个 task 可以通过 processor 中的一个 thread 执行。每个 thread 可以线性的执行程序。通过这种方式单核 CUP 也能执行多线程，而且这对使用者是透明的，你不需要关心他的具体实现。</p>
<h3 id="Defining-tasks"><a href="#Defining-tasks" class="headerlink" title="Defining tasks"></a>Defining tasks</h3><p>并发中一个 thread 对应一个 task, 我们通过实现 Runnable 接口并实现 run() 方法的形式实现并发。</p>
<p>示例说明:</p>
<p>多线程打印变量指，run() 方法中有个 while 循环让 countDown 值递减，然后调用 print 方法打印状态信息。countDown = 0 时结束 task 并推出。</p>
<p>Thread.yield() 是 Thread 类自带的方法，作用是告诉 CPU 现在是时候让渡时间片了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> countDown = <span class="number">10</span>; <span class="comment">// Default</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = taskCount++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">(<span class="keyword">int</span> countDown)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDown = countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id + <span class="string">&quot;(&quot;</span> + (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">&quot;Liftoff!&quot;</span>) + <span class="string">&quot;), &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (countDown-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(status());</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LiftOff launch = <span class="keyword">new</span> LiftOff();</span><br><span class="line">        launch.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),</span></span><br></pre></td></tr></table></figure>

<p>除了调用 run() 方法，还可以将 Runnable 类传给 Thread 类并调用 start() 方法启动线程。下面的例子中，我们在主函数中新建五个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreBasicThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff()).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for LiftOff...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #0(9), #1(9), #2(9), #0(8), #2(8), #1(8), #2(7), #0(7), #2(6),</span></span><br><span class="line"><span class="comment">// #3(9), #2(5), #3(8), #4(9), #3(7), #0(6), #3(6), Waiting for LiftOff...</span></span><br><span class="line"><span class="comment">// #1(7), #3(5), #0(5), #4(8), #2(4), #4(7), #0(4), #4(6), #3(4),</span></span><br><span class="line"><span class="comment">// #1(6), #3(3), #1(5), #4(5), #1(4), #0(3), #2(3), #1(3), #4(4),</span></span><br><span class="line"><span class="comment">// #2(2), #4(3), #3(2), #4(2), #2(1), #1(2), #0(2), #2(Liftoff!),</span></span><br><span class="line"><span class="comment">// #0(1), #4(1), #0(Liftoff!), #3(1), #4(Liftoff!), #1(1),</span></span><br><span class="line"><span class="comment">// #3(Liftoff!), #1(Liftoff!),</span></span><br></pre></td></tr></table></figure>

<p>从输出我们可以看出来，各个线程的 task 是混合执行的，通过 thread scheduler 调度。如果你使用的是多核系统，scheduler 会帮你讲这些 task 分配到不同核上计算。</p>
<p>main() 函数并不会持有创建出来的 Thread 的引用。对普通的对象来说，这会影响到垃圾回收，但是 Thread 有特殊的机制保证这一点。他会一直存在知道 run() 方法结束为止。</p>
<h3 id="Using-Executors"><a href="#Using-Executors" class="headerlink" title="Using Executors"></a>Using Executors</h3><p>Java SE5 以来，提供了另一种执行并发的方式 - Executor. 通过它你就不需要在 Client 中新建 Thread 来执行这个 task 了。Executor 是 Java5/6 中提倡的运行并发的方式。</p>
<p>Executor 提供了多种运行方式，有 CachedThreadPool, FixedThreadPool 和 SingleThreadPool.</p>
<p>CachedThreadPool 的例子如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #0(9), #1(9), #2(9), #0(8), #2(8), #1(8), #3(9), #2(7), </span></span><br><span class="line"><span class="comment">// #0(7), #2(6), #3(8), #2(5), #1(7), #3(7), #2(4), #4(9), </span></span><br><span class="line"><span class="comment">// #4(8), #0(6), #4(7), #2(3), #3(6), #1(6), #3(5), #1(5), </span></span><br><span class="line"><span class="comment">// #2(2), #0(5), #0(4), #4(6), #0(3), #2(1), #1(4), #3(4), </span></span><br><span class="line"><span class="comment">// #2(Liftoff!), #3(3), #0(2), #4(5), #0(1), #3(2), #1(3), </span></span><br><span class="line"><span class="comment">// #3(1), #0(Liftoff!), #3(Liftoff!), #4(4), #1(2), #4(3), </span></span><br><span class="line"><span class="comment">// #1(1), #4(2), #1(Liftoff!), #4(1), #4(Liftoff!),</span></span><br></pre></td></tr></table></figure>

<p>task execute 之后需要调用 shutdown 方法防止新的 task 被提交到 Executor 中。</p>
<p>下面是 FixedThreadPool 的使用方法，和前面基本一样，我们可以自定义 pool size</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于 CachedThreadPool, FixedThreadPool 会在开始前一并将制定的 Thread 都创建完以节省创建成本。同时由于指定了线程数，可以防止资源滥用。</p>
<p>书中例子都是用的 CachedTheadPool, 因为方便，他的机制是，更具使用情况创建线程，如果之前的线程用完了，会重用。产品代码还是尽量使用 FixedThreadPool 为好。</p>
<p>SingleThreadPool 和 FixedThreadPool 很像，只不过限定只能是单线程。这种情况在 常驻线程 和 临时线程 的情况下很有用。如果多个 task 被提交到 SingleThreadPool 中的话，他会顺序执行所有的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), </span></span><br><span class="line"><span class="comment">// #0(1), #0(Liftoff!), #1(9), #1(8), #1(7), #1(6), #1(5), </span></span><br><span class="line"><span class="comment">// #1(4), #1(3), #1(2), #1(1), #1(Liftoff!), #2(9), #2(8), </span></span><br><span class="line"><span class="comment">// #2(7), #2(6), #2(5), #2(4), #2(3), #2(2), #2(1), #2(Liftoff!), </span></span><br><span class="line"><span class="comment">// #3(9), #3(8), #3(7), #3(6), #3(5), #3(4), #3(3), #3(2), #3(1), </span></span><br><span class="line"><span class="comment">// #3(Liftoff!), #4(9), #4(8), #4(7), #4(6), #4(5), #4(4), #4(3), </span></span><br><span class="line"><span class="comment">// #4(2), #4(1), #4(Liftoff!),</span></span><br></pre></td></tr></table></figure>

<p>通过 SingleThreadExectuor 你可以确保同一时间只有一个线程占用某个资源。如果读写文件系统时，可以通过这中 executor 避免死锁。当然最常见的还是给资源加锁，后面有介绍。</p>
<h3 id="Producing-return-values-from-tasks"><a href="#Producing-return-values-from-tasks" class="headerlink" title="Producing return values from tasks"></a>Producing return values from tasks</h3><p>Runnable 的方式，当 run 结束时即退出，是没有返回值的，如果想要在 task 结束后返回值，可以使用 Callable 接口，从 Java 5 开始支持这个接口。他只能通过 ExecutorService 的 submit 进行调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fs : results) &#123;</span><br><span class="line">            System.out.println(fs.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result of TaskWithResult 0</span></span><br><span class="line"><span class="comment">// result of TaskWithResult 1</span></span><br><span class="line"><span class="comment">// result of TaskWithResult 2</span></span><br><span class="line"><span class="comment">// result of TaskWithResult 3</span></span><br><span class="line"><span class="comment">// result of TaskWithResult 4</span></span><br><span class="line"><span class="comment">// result of TaskWithResult 5</span></span><br><span class="line"><span class="comment">// result of TaskWithResult 6</span></span><br><span class="line"><span class="comment">// result of TaskWithResult 7</span></span><br><span class="line"><span class="comment">// result of TaskWithResult 8</span></span><br><span class="line"><span class="comment">// result of TaskWithResult 9</span></span><br></pre></td></tr></table></figure>

<p>submit() 方法会产生一个 Future 对象来存储 Callable 的结果。Future 提供 isDone() 方法用以检测 task 是否执行结束。结束后可以执行 get() 方法得到结果。如果直接调用 get() 但是 task 还没有 done, 那 get() 就会 block 直到 task 完成，你也可以为 get() 设置 timeout。</p>
<h3 id="Sleeping"><a href="#Sleeping" class="headerlink" title="Sleeping"></a>Sleeping</h3><p>在 task 中，你可以通过调用 sleep() 方法来影响 task 的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepingTask</span> <span class="keyword">extends</span> <span class="title">LiftOff</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (countDown-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(status());</span><br><span class="line">                <span class="comment">// Old-style: Thread.sleep(100);</span></span><br><span class="line">                <span class="comment">// Java SE5/6-style</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SleepingTask());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #0(9), #2(9), #1(9), #3(9), #4(9), </span></span><br><span class="line"><span class="comment">// #0(8), #2(8), #1(8), #4(8), #3(8), </span></span><br><span class="line"><span class="comment">// #4(7), #1(7), #3(7), #2(7), #0(7), </span></span><br><span class="line"><span class="comment">// #1(6), #4(6), #3(6), #0(6), #2(6), </span></span><br><span class="line"><span class="comment">// #1(5), #4(5), #3(5), #0(5), #2(5), </span></span><br><span class="line"><span class="comment">// #4(4), #0(4), #2(4), #3(4), #1(4), </span></span><br><span class="line"><span class="comment">// #4(3), #0(3), #1(3), #3(3), #2(3), </span></span><br><span class="line"><span class="comment">// #3(2), #2(2), #0(2), #4(2), #1(2), </span></span><br><span class="line"><span class="comment">// #2(1), #3(1), #4(1), #0(1), #1(1), </span></span><br><span class="line"><span class="comment">// #4(Liftoff!), #3(Liftoff!), #2(Liftoff!), #0(Liftoff!), #1(Liftoff!),</span></span><br></pre></td></tr></table></figure>

<p>sleep() 会抛出 InterruptedException 异常，你必须在 run() 方法中处理他，因为异常是不能被传递到 main 中的。 TimeUnit 是对 Thread.sleep() 更精确的处理方式。</p>
<p>从输出内容我们可以看到，加了 sleep 之后 task 以轮训的形式输出，但是这个是不能保证的，不同的操作系统可能有不同的行为。</p>
<h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><p>priority 表示 thread 在 scheduler 总的重要程度。scheduler 会倾向于更频繁的调用 priority 高的 thread。</p>
<p>一般来说，你不需要人为的制定 thread priority，系统会自动为你分配。你可以调用 getPriority()/setPriority() 查看，指定优先级</p>
<p>示例如下，和前面的 LiftOff 基本一致，只是 run() 中的实现改为 10w 浮点计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePriorities</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d; <span class="comment">// No optimization</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimplePriorities</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread() + <span class="string">&quot;: &quot;</span> + countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setPriority(priority);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// An expensive, interruptable operation</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                d += (Math.PI + Math.E) / (<span class="keyword">double</span>) i;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">                    Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MIN_PRIORITY));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MAX_PRIORITY));</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Thread[pool-1-thread-2,1,main]: 5</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-3,1,main]: 5</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-5,1,main]: 5</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-1,1,main]: 5</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-4,1,main]: 5</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-6,10,main]: 5</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-3,1,main]: 4</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-2,1,main]: 4</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-5,1,main]: 4</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-4,1,main]: 4</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-1,1,main]: 4</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-6,10,main]: 4</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-3,1,main]: 3</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-1,1,main]: 3</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-5,1,main]: 3</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-2,1,main]: 3</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-4,1,main]: 3</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-3,1,main]: 2</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-6,10,main]: 3</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-1,1,main]: 2</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-5,1,main]: 2</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-3,1,main]: 1</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-6,10,main]: 2</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-4,1,main]: 2</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-2,1,main]: 2</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-1,1,main]: 1</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-6,10,main]: 1</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-5,1,main]: 1</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-4,1,main]: 1</span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-2,1,main]: 1</span></span><br></pre></td></tr></table></figure>

<p>Thread 的 toString 方法有自定义过，输出时会打印 thread name + priority + group name. </p>
<p>Mac 上跑这个实验效果并不明显，期望值应该是 CPU 会优先执行 priority 为 5 的线程才对。。。</p>
<p>下面解释 d 变量增加这个 volatile 就是为了防止优化，不然看不到预期结果。难道 mac 上这个设置失效了？！之后调用 yield 释放线权。</p>
<p>JDK 有 10 个等级的优先级设置，不一定和操作系统匹配，比如 Windows 只有 7 级而 Linux 系统有 23 级。</p>
<h3 id="Yielding"><a href="#Yielding" class="headerlink" title="Yielding"></a>Yielding</h3><p>通过使用 yield 可以在 task 进行过程中，让渡 CPU 给其他同级别的 task，但是这个让渡并不能被保证，你不能通过他来严格控制 task 的执行顺序。</p>
<h3 id="Daemon-threads"><a href="#Daemon-threads" class="headerlink" title="Daemon threads"></a>Daemon threads</h3><p>守护进程可以在成勋运行时在后台提供一些其他的基础服务，但是这个服务和程序没关系。当所有 非守进程 的程序结束后，守护进程也会被杀死，程序退出。反之，只要有 非守护进程 没有结束，那么守护进程就不会结束。</p>
<p>示例演示</p>
<p>run 方法总我们指定新建的 thread 为 守护进程。当 main 结束时，守护进程也一起结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDaemons</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread daemon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SimpleDaemons());</span><br><span class="line">            daemon.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            daemon.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;All daemons started&quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">175</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All daemons started</span></span><br><span class="line"><span class="comment">// Thread[Thread-5,5,main] org.jz.c23.SimpleDaemons@501a67ca</span></span><br><span class="line"><span class="comment">// Thread[Thread-8,5,main] org.jz.c23.SimpleDaemons@22e706f4</span></span><br><span class="line"><span class="comment">// Thread[Thread-2,5,main] org.jz.c23.SimpleDaemons@4eba943c</span></span><br><span class="line"><span class="comment">// Thread[Thread-0,5,main] org.jz.c23.SimpleDaemons@c0a422e</span></span><br><span class="line"><span class="comment">// Thread[Thread-7,5,main] org.jz.c23.SimpleDaemons@317704a2</span></span><br><span class="line"><span class="comment">// Thread[Thread-3,5,main] org.jz.c23.SimpleDaemons@5ed3479d</span></span><br><span class="line"><span class="comment">// Thread[Thread-6,5,main] org.jz.c23.SimpleDaemons@2482ac6c</span></span><br><span class="line"><span class="comment">// Thread[Thread-9,5,main] org.jz.c23.SimpleDaemons@205caa11</span></span><br><span class="line"><span class="comment">// Thread[Thread-1,5,main] org.jz.c23.SimpleDaemons@71537d82</span></span><br><span class="line"><span class="comment">// Thread[Thread-4,5,main] org.jz.c23.SimpleDaemons@1b02d47b</span></span><br></pre></td></tr></table></figure>

<p>我们还可以通过定制 ThreadFactory 来生成 Thread. 然后通过 Executors 来做并发</p>
<p>示例说明：</p>
<p>main 中新建了一个 ExecutorService 并用 DaemonThreadFactory 作为参数。通过这种方式，所有创建的并发线程都是守护进程。他们会每隔 100ms 打印一次信息。同时 main 会 sleep 500ms 然后退出。同时守护进程全部结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonFromFactory</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool(<span class="keyword">new</span> DaemonThreadFactory());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> DaemonFromFactory());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;All daemons started&quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All daemons started</span></span><br><span class="line"><span class="comment">// Thread[Thread-9,5,main] org.jz.c23.DaemonFromFactory@627a6c14</span></span><br><span class="line"><span class="comment">// Thread[Thread-6,5,main] org.jz.c23.DaemonFromFactory@43ca4e8</span></span><br><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure>

<p>我们还可以使用 ThreadPoolExecutor 来简化上面的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DaemonThreadPoolExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, </span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), <span class="keyword">new</span> DaemonThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以通过调用 isDaemon() 方法查看线程是否为 守护进程，由 守护进程 创建的所有 thread 都会自动变为 守护进程。</p>
<p>示例说明：</p>
<p>main 函数中为 Daemon 创建线程，并制定类型为 守护进程</p>
<p>Daemon 这个进程中会新建并启动十个 thread，逻辑都一样，就是生产后一直空转</p>
<p>打印这十个空转进程的类型，可以看到也是 守护进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemons</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread d = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Daemon());</span><br><span class="line">        d.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        d.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;d.isDaemon() = &quot;</span> + d.isDaemon() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="comment">// Allow the daemon threads to finish their startup processes</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaemonSpawn</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread[] t = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">            t[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonSpawn());</span><br><span class="line">            t[i].start();</span><br><span class="line">            System.out.println(<span class="string">&quot;DaemonSpawn &quot;</span> + i + <span class="string">&quot; started, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t[&quot;</span> + i + <span class="string">&quot;].isDaemon() = &quot;</span> + t[i].isDaemon() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// d.isDaemon() = true, </span></span><br><span class="line"><span class="comment">// DaemonSpawn 0 started, </span></span><br><span class="line"><span class="comment">// DaemonSpawn 1 started, </span></span><br><span class="line"><span class="comment">// DaemonSpawn 2 started, </span></span><br><span class="line"><span class="comment">// DaemonSpawn 3 started, </span></span><br><span class="line"><span class="comment">// DaemonSpawn 4 started, </span></span><br><span class="line"><span class="comment">// DaemonSpawn 5 started, </span></span><br><span class="line"><span class="comment">// DaemonSpawn 6 started, </span></span><br><span class="line"><span class="comment">// DaemonSpawn 7 started, </span></span><br><span class="line"><span class="comment">// DaemonSpawn 8 started, </span></span><br><span class="line"><span class="comment">// DaemonSpawn 9 started, </span></span><br><span class="line"><span class="comment">// t[0].isDaemon() = true, </span></span><br><span class="line"><span class="comment">// t[1].isDaemon() = true, </span></span><br><span class="line"><span class="comment">// t[2].isDaemon() = true, </span></span><br><span class="line"><span class="comment">// t[3].isDaemon() = true, </span></span><br><span class="line"><span class="comment">// t[4].isDaemon() = true, </span></span><br><span class="line"><span class="comment">// t[5].isDaemon() = true, </span></span><br><span class="line"><span class="comment">// t[6].isDaemon() = true, </span></span><br><span class="line"><span class="comment">// t[7].isDaemon() = true, </span></span><br><span class="line"><span class="comment">// t[8].isDaemon() = true, </span></span><br></pre></td></tr></table></figure>

<p>注意：守护进程是可以在不执行 finally 的情况下退出的</p>
<p>示例说明：</p>
<p>主函数中新建一个 ADaemon 的 thread 并启动。 ADaemon 的 run 方法会答应 “Starting ADaemon” 并在 1s 后打印 “This should always run?”</p>
<p>祝函数启动并结束后，守护进程的 finally 中的语句并没有打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ADaemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Starting ADaemon&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This should always run?&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonsDontRunFinally</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ADaemon());</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Starting ADaemon</span></span><br></pre></td></tr></table></figure>

<p>如果我们将 t.setDaemon(true); 注释掉，则 finally 中的内容会被打印出来。</p>
<p>守护进程在没有其他 非守护进程 的时候会立即别 JVM 杀掉。所以一般来说鼓励创建 非守护进程。我们可以通过 Executor 关闭 非守护进程，后面会介绍。</p>
<h3 id="Coding-variations"><a href="#Coding-variations" class="headerlink" title="Coding variations"></a>Coding variations</h3><p>到现在为止，我们都用 Runnable 实现并发，其实并发还可以通过很多其他不同的方式实现</p>
<p>通过继承 Thread 类, 和 Runnable 的区别：</p>
<ul>
<li>Runnable 需要通过 Thread 类或者 Executor 才能启动，Thread 自己就可以启动</li>
<li>Runnable 启动时需要调用 start() 方法，Thread 不需要，new 完就启动了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Integer.toString(++threadCount));</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + getName() + <span class="string">&quot;(&quot;</span> + countDown + <span class="string">&quot;), &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (--countDown == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> SimpleThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1(5), #1(4), #3(5), #3(4), #3(3), #3(2), #3(1), #4(5), #4(4), </span></span><br><span class="line"><span class="comment">// #2(5), #4(3), #4(2), #1(3), #1(2), #1(1), #4(1), #5(5), #5(4), </span></span><br><span class="line"><span class="comment">// #2(4), #5(3), #2(3), #2(2), #2(1), #5(2), #5(1), </span></span><br></pre></td></tr></table></figure>

<p>还可以在 Runnable 的实现中自启动, 这种写法的特点是，在成员变量中，将本身作为参数传给 Thread 的构造函数。在自己的构造函数中，调用 Thread 的 start 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfManaged</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelfManaged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;(&quot;</span> + countDown + <span class="string">&quot;), &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (--countDown == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> SelfManaged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Thread-0(5), Thread-2(5), Thread-1(5), Thread-3(5), Thread-2(4), Thread-2(3), </span></span><br><span class="line"><span class="comment">// Thread-4(5), Thread-4(4), Thread-0(4), Thread-4(3), Thread-4(2), Thread-2(2), </span></span><br><span class="line"><span class="comment">// Thread-3(4), Thread-3(3), Thread-3(2), Thread-3(1), Thread-1(4), Thread-2(1), </span></span><br><span class="line"><span class="comment">// Thread-4(1), Thread-0(3), Thread-0(2), Thread-1(3), Thread-0(1), Thread-1(2), </span></span><br><span class="line"><span class="comment">// Thread-1(1),</span></span><br></pre></td></tr></table></figure>

<p>PS: 这个例子中使用场景很简单，所以可能没什么风险，但是在构造函数中启动线程可能会很危险。其他 task 可能在这个 task 初始化结束之前就开始使用这个 task 对应的 thread，这个对象此时处于一个不稳定状态。这就是我们更倾向于使用 Executor 的原因</p>
<p>有时候，你并不想对外暴露并发类的实现，此时，你可以使用内部类的方式。以下是几种典型应用方式</p>
<p>通过显示的内部类实现</p>
<ul>
<li>InnerThread1 包含内部类 Inner，内部类继承 Thread</li>
<li>Inner 的构造函数会调用 start 方法启动线程</li>
<li>InnerThread1 有构造函数，调用 Inner 的构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using a named inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerThread1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Inner inner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        Inner(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                    sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getName() + <span class="string">&quot;: &quot;</span> + countDown;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerThread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        inner = <span class="keyword">new</span> Inner(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过显示的内部类实现, 和上面的例子大同小异，只是把  Thread 类的声明塞到了 InnerThread2 构造函数中，然后直接调用 start() 开启线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using an anonymous inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerThread2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerThread2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        t = <span class="keyword">new</span> Thread(name) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                        sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getName() + <span class="string">&quot;: &quot;</span> + countDown;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类 + Runnable, 和第一个例子类似，只不过通过 Runnable 接口做实现，start 的调用直接放在 Inner 的构造函数中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using a named Runnable implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerRunnable1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Inner inner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, name);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t.getName() + <span class="string">&quot;: &quot;</span> + countDown;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerRunnable1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        inner = <span class="keyword">new</span> Inner(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类 + Runnable, Runnable 实现放在构造函数中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using an anonymous Runnable implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerRunnable2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerRunnable2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + countDown;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, name);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 Runnable 放到方法中做实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A separate method tu run some code as a task</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadMethod</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadMethod</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread(name) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                            <span class="keyword">if</span> (--countDown == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                            sleep(<span class="number">10</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadVariations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerThread1(<span class="string">&quot;InnerThread1&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerThread2(<span class="string">&quot;InnerThread2&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerRunnable1(<span class="string">&quot;InnerRunnable1&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> InnerRunnable2(<span class="string">&quot;InnerRunnable2&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> ThreadMethod(<span class="string">&quot;ThreadMethod&quot;</span>).runTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h3><p>术语解释，没发现什么有趣的点</p>
<h3 id="Joining-a-thread"><a href="#Joining-a-thread" class="headerlink" title="Joining a thread"></a>Joining a thread</h3><p>在线程 A 的执行中，如果你 call 了线程 B 的 join() 方法，那么，线程 A 会等待线程 B 结束后再执行。</p>
<p>上面的 join 的行为可以通过调用 B 的 interrup() 方法进行打断</p>
<p>示例解析：</p>
<p>Sleeper 继承自 Thread 通过构造函数指定线程名称和休眠时间。当被打断时输出日志。</p>
<p>Joiner 继承自 Thread, 通过参数指定 Thread name 和将要 join 的 thread</p>
<p>主程序中，创建两个 Sleeper 类，再创建两个 Joiner 类并将 Sleeper 分别传给他们。</p>
<p>Joiner 执行的时候，会等待传入的 Sleeper 执行结束再继续执行。其中一个 Sleper 调用 interrupt() 方法，中途中断，对应的 Joiner 继续执行</p>
<p>PS: 当现场被打断时，isInterrupted 被设置为 true, 当异常被捕获时，重制为 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">joining</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sleeper</span><br><span class="line">                sleepy = <span class="keyword">new</span> Sleeper(<span class="string">&quot;Sleepy&quot;</span>, <span class="number">1500</span>),</span><br><span class="line">                grumpy = <span class="keyword">new</span> Sleeper(<span class="string">&quot;Grumpy&quot;</span>, <span class="number">1500</span>);</span><br><span class="line">        Joiner</span><br><span class="line">                dopey = <span class="keyword">new</span> Joiner(<span class="string">&quot;Dopey&quot;</span>, sleepy),</span><br><span class="line">                doc = <span class="keyword">new</span> Joiner(<span class="string">&quot;Doc&quot;</span>, grumpy);</span><br><span class="line">        grumpy.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sleeper</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> duration;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Sleeper</span> <span class="params">(String name, <span class="keyword">int</span> sleepTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        duration = sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(duration);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; was interrupted. &quot;</span> + <span class="string">&quot;isInterrupted(): &quot;</span> + isInterrupted());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; has awakened&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Joiner</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sleeper sleeper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Joiner</span><span class="params">(String name, Sleeper sleeper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.sleeper = sleeper;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleeper.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; join completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grumpy was interrupted. isInterrupted(): false</span></span><br><span class="line"><span class="comment">// Doc join completed</span></span><br><span class="line"><span class="comment">// Sleepy has awakened</span></span><br><span class="line"><span class="comment">// Dopey join completed</span></span><br></pre></td></tr></table></figure>

<h3 id="Creating-responsive-user-interface"><a href="#Creating-responsive-user-interface" class="headerlink" title="Creating responsive user interface"></a>Creating responsive user interface</h3><p>模拟图形界面，但是不太能 get 到他的点，pass</p>
<h3 id="Thread-groups"><a href="#Thread-groups" class="headerlink" title="Thread groups"></a>Thread groups</h3><p>Thread group 是一个失败的作品，你最好忘记他的存在</p>
<h3 id="Catching-exceptions"><a href="#Catching-exceptions" class="headerlink" title="Catching exceptions"></a>Catching exceptions</h3><p>由于 Thread 的特性，run() 中抛出的异常，你不能在 main 中 catch。示例如下，我们新建一个 Runnable 的实现类，并让跑抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;pool-1-thread-1&quot; java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">//     at org.jz.c23.ExceptionThread.run(ExceptionThread.java:9)</span></span><br><span class="line"><span class="comment">//     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span></span><br><span class="line"><span class="comment">//     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span></span><br><span class="line"><span class="comment">//     at java.lang.Thread.run(Thread.java:836)</span></span><br></pre></td></tr></table></figure>

<p>我们在 executor 外面添加 try-catch 试图捕获异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaiveExceptionHandling</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">            exec.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception has been handled...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;pool-1-thread-1&quot; java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">//     at org.jz.c23.ExceptionThread.run(ExceptionThread.java:9)</span></span><br><span class="line"><span class="comment">//     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span></span><br><span class="line"><span class="comment">//     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span></span><br><span class="line"><span class="comment">//     at java.lang.Thread.run(Thread.java:836)</span></span><br></pre></td></tr></table></figure>

<p>然并卵。。。。这时，你可以结合 Executor 使用它，在 new pool 的时候指定 factory， 并在 factory 的实现中指定异常的处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureUncaughtException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool(<span class="keyword">new</span> HandlerThreadFactory());</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;run() by &quot;</span> + t);</span><br><span class="line">        System.out.println(<span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;caught &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span> + <span class="string">&quot; creating new thread&quot;</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        System.out.println(<span class="string">&quot;create &quot;</span> + t);</span><br><span class="line">        t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        System.out.println(<span class="string">&quot;eh = &quot;</span> + t.getUncaughtExceptionHandler());</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.jz.c23.HandlerThreadFactory@39a054a5 creating new thread</span></span><br><span class="line"><span class="comment">// create Thread[Thread-0,5,main]</span></span><br><span class="line"><span class="comment">// eh = org.jz.c23.MyUncaughtExceptionHandler@6ed3ef1</span></span><br><span class="line"><span class="comment">// run() by Thread[Thread-0,5,main]</span></span><br><span class="line"><span class="comment">// eh = org.jz.c23.MyUncaughtExceptionHandler@6ed3ef1</span></span><br><span class="line"><span class="comment">// org.jz.c23.HandlerThreadFactory@39a054a5 creating new thread</span></span><br><span class="line"><span class="comment">// create Thread[Thread-1,5,main]</span></span><br><span class="line"><span class="comment">// eh = org.jz.c23.MyUncaughtExceptionHandler@78463d45</span></span><br><span class="line"><span class="comment">// caught java.lang.RuntimeException</span></span><br></pre></td></tr></table></figure>

<p>PS: 不知道为毛会有两次创建 handler 的动作，好奇怪</p>
<p>如果所有的异常都是一个 handler 处理的，还可以直接将 handler 设置给 Thread 简化操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingDefaultHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// caught java.lang.RuntimeException</span></span><br></pre></td></tr></table></figure>

<p>中间中间好几节暂时不用，先放一放</p>
<h2 id="Sharing-resources"><a href="#Sharing-resources" class="headerlink" title="Sharing resources"></a>Sharing resources</h2><p>并发需要解决的是多个线程操作共用资源的问题</p>
<h3 id="Improperly-accessing-resources"><a href="#Improperly-accessing-resources" class="headerlink" title="Improperly accessing resources"></a>Improperly accessing resources</h3><p>举一个多线程使用 int 生成器的例子。我们创建一个生成器的抽象接口,定义了抽象类中的方法。</p>
<ul>
<li>next() - 生成 int 结果</li>
<li>cancel() - 设置 flag</li>
<li>isCancel() - 返回 flag 结果</li>
</ul>
<p>canceled 这个 flag 还被定义为 volatile 确保其他线程可见</p>
<p>cancel() 为 boolean 赋值语句，是一个原子操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; canceled = <span class="keyword">true</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> canceled; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义 EvenChecker 并发检测奇偶情况.</p>
<ul>
<li>run() - 拿到生成的 int 值并判断，如果为奇数则停止线程</li>
<li>test() - 重载了两个 test 方法，启动多个线程运行 run 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IntGenerator generator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvenChecker</span><span class="params">(IntGenerator g, <span class="keyword">int</span> ident)</span> </span>&#123;</span><br><span class="line">        generator = g;</span><br><span class="line">        id = ident;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!generator.isCanceled()) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = generator.next();</span><br><span class="line">            <span class="keyword">if</span> (val % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(val + <span class="string">&quot; not event...&quot;</span>);</span><br><span class="line">                generator.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntGenerator gp, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Ctrl + c to exit&quot;</span>);</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> EvenChecker(gp, i));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(IntGenerator gp)</span> </span>&#123;</span><br><span class="line">        test(gp, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成器的实现类 EvenGenerator, 声明一个初始值，并通过两个 ++ 运算，达到偶数次递增的目的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++currentEvenValue;</span><br><span class="line">        ++currentEvenValue;</span><br><span class="line">        <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> EvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Ctrl + c to exit</span></span><br><span class="line"><span class="comment">// 1515 not event...</span></span><br><span class="line"><span class="comment">// 1519 not event...</span></span><br><span class="line"><span class="comment">// 1517 not event...</span></span><br></pre></td></tr></table></figure>

<p>运行后可以看到，三个线程检测到目标为奇数，停止了 generator。当执行 next() 时，有可能执行了一半，切到另一个线程执行 run() 中的判断了。这时，程序状态就会出错。你还可以在两个 ++ 操作中间通过新加 yield() 方法来加大重现频率。</p>
<p>还有一个需要注意的是 i++ 并不是一个原子操作，可能在执行间就切到另一个线程了。</p>
<h3 id="Resolving-shared-resource-contention"><a href="#Resolving-shared-resource-contention" class="headerlink" title="Resolving shared resource contention"></a>Resolving shared resource contention</h3><p>这里举了一个挺有意思的例子，处理并发就像是 你坐在餐桌上，准备夹一块肉的时候，突然，肉没了(你的线程被暂停，同时其他线程操作了这个资源)</p>
<p>你可以通过加锁防止这种事情的发生，这样保证一个资源同一时间只能由一个 task 访问，其他 task 需要排队等待解锁。</p>
<p>代码层面，Java 通过 synchronized 关键字来实现这一功能。shared resource 同行来说是一片系统内存，以对象的形式表现出来。也可能是一个文件，或者 IO 端口或者一些设备，比如打印机之类的。</p>
<p>你需要将 class 中代表你要 lock 的对象声明为 private，并且所有和这个对象相关的方法前加关键字，示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当一个方法被调用的时候，其他加了关键字的方法都会被 lock 住，直到前一个方法执行完毕为止。</p>
<p>PS: 将用到的对象声明为 private 是很关键的一步，否则控制并发会失败。</p>
<p>上述对象在 JVM 有一个 field 来记录锁的数量，默认为 0，当 synchronized 方法被调用时，count + 1，当对应的 task 调用这个对象的两一个 synchronized 方法时，再 + 1.</p>
<p>此外还有 class level 的 lock 用来控制 static 方法的同步，保证同一时间只有一个 task 访问这个静态方法。</p>
<p>加锁的原则：This is an important point: Every method that accesses a critical shared resource must be synchronized or it won’t work right.</p>
<h3 id="Synchronizing-the-EvenGenerator"><a href="#Synchronizing-the-EvenGenerator" class="headerlink" title="Synchronizing the EvenGenerator"></a>Synchronizing the EvenGenerator</h3><p>根据上一节的描述，我们通过给 next 方法加锁，将之前的 EvenGenerator 改为线程安全版本.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++currentEvenValue;</span><br><span class="line">        Thread.yield();</span><br><span class="line">        ++currentEvenValue;</span><br><span class="line">        <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> SynchronizedEvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Using-explicit-Lock-objects"><a href="#Using-explicit-Lock-objects" class="headerlink" title="Using explicit Lock objects"></a>Using explicit Lock objects</h3><p>Java 5 的 concurrent 包中提供了一个 Lock 类来更精确的控制锁的范围，示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEventValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ++currentEventValue;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            ++currentEventValue;</span><br><span class="line">            <span class="keyword">return</span> currentEventValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> MutexEvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用上面这种写法，你需要注意， 调用 lock() 方法之后，一定要用 try-finally 的语法，将 unlock 放到 finally 中，并切 try block 里面完成 return 的动作，防止指在外面被改动。</p>
<p>相比于传统的 synchronized 方式，try-finally 代码更多，但是它给你机会再程序出错时做出补救。</p>
<p>通过使用 concurrent 包下的方法，你可以实现 re-try 的机制</p>
<p>下面的例子中定义了两个方法，untimed/timed 功能都是一样的，尝试获取锁，并打印获取的情况。main 中一开始，顺序执行，两个方法可以拿到锁，并在使用完后释放。后面通过匿名类，启动一个新线程，获取锁并不释放，后面再次调用之前的方法，返回获取锁失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">untimed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured = lock.tryLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;tryLock(): &quot;</span> + captured);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(captured)</span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            captured = lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;tryLock(2, TimeUnit.SECONDS): &quot;</span> + captured);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (captured)</span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AttemptLocking al = <span class="keyword">new</span> AttemptLocking();</span><br><span class="line">        al.untimed();</span><br><span class="line">        al.timed();</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            &#123;setDaemon(<span class="keyword">true</span>);&#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                al.lock.lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;acquired&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        al.untimed();</span><br><span class="line">        al.timed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tryLock(): true</span></span><br><span class="line"><span class="comment">// tryLock(2, TimeUnit.SECONDS): true</span></span><br><span class="line"><span class="comment">// tryLock(): true</span></span><br><span class="line"><span class="comment">// acquired</span></span><br><span class="line"><span class="comment">// tryLock(2, TimeUnit.SECONDS): false</span></span><br></pre></td></tr></table></figure>

<h3 id="Atomicity-and-volatility"><a href="#Atomicity-and-volatility" class="headerlink" title="Atomicity and volatility"></a>Atomicity and volatility</h3><p>一个原子操作是指，如果这个操作开始了，那么只有在操作结束后，JVM 才会考虑进行上下文切换。考虑到原子操作这么冷门而且很危险，建议专家级别了再作原子操作代替 synchronized 的优化。</p>
<blockquote>
<p>The Goetz Test: If you can write a hight-perormance JVM for a modern microprocessor, then you are qualified to think about whether you can avoid synchronizing.</p>
</blockquote>
<p>鼓励使用官方为你写的工具包(concurrent)，而不是自己造的轮子。</p>
<p>‘simple operation’ 和 除了 long/double 的 primitive 类型的数据操作都是原子操作。JVM 在处理 long/double 时会分成两个指令处理，但是如果你为这两类数据加上 volatile 修饰之后，可以保证原子性。</p>
<p>在多核处理器系统中，visibility 是比 atomicity 更容易出问题的点。一个 task 进行的一个原子操作，由于改动存放在本地处理器的 cache 中，导致其他 task 不知道这个改动，从而导致不同 task 之间 application 的状态不一致。synchronization 机制可以保证一个 task 的改动在其他 task 上也可以被观察到。</p>
<p>volatile 也可以保证这一点。如果你声明了一个 volatile 变量，一旦写操作执行了，那么所有要读他的地方会立即观察到这个变化，其实是 local cache 的情况也能保证。volatile 会保证 write 的动作立即反应到驻内存中。</p>
<p>atomicity 和 volatility 是两个概念，一个非 volatile 的原子操作并不会被 flush 到主内存中，如果多个 task 对他进行操作，会产生不一致。如果多个 task 都要访问一个 field，那么他就需要声明为 volatile 类型，或者用 synchronization 来管理他。如果用了 synchronizaiton 管理，就不需要用 volatile 修饰了</p>
<p>优先考虑用 synchronization，这个是最安全的解决方案。</p>
<p>Java 中赋值和返回语句是原子操作，自增/减不是。。。Java 反编译自增代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: concurrency/Atomicity.java</span></span><br><span class="line"><span class="comment">// &#123;Exec: javap -c Atomicity&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Atomicity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; i++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; i += <span class="number">3</span>; &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* Output: (Sample) </span></span><br><span class="line"><span class="comment">... void f1();</span></span><br><span class="line"><span class="comment">   Code:</span></span><br><span class="line"><span class="comment">    0:        aload_0    </span></span><br><span class="line"><span class="comment">    1:        dup    </span></span><br><span class="line"><span class="comment">    2:        getfield        #2; //Field i:I    </span></span><br><span class="line"><span class="comment">    5:        iconst_1    </span></span><br><span class="line"><span class="comment">    6:        iadd    </span></span><br><span class="line"><span class="comment">    7:        putfield        #2; //Field i:I    </span></span><br><span class="line"><span class="comment">    10:        return  </span></span><br><span class="line"><span class="comment">void f2();</span></span><br><span class="line"><span class="comment">   Code:    </span></span><br><span class="line"><span class="comment">   0:        aload_0    </span></span><br><span class="line"><span class="comment">   1:        dup    </span></span><br><span class="line"><span class="comment">   2:        getfield        #2; //Field i:I    </span></span><br><span class="line"><span class="comment">   5:        iconst_3    </span></span><br><span class="line"><span class="comment">   6:        iadd    </span></span><br><span class="line"><span class="comment">   7:        putfield        #2; //Field i:I    </span></span><br><span class="line"><span class="comment">   10:        return</span></span><br></pre></td></tr></table></figure>

<p>可以看到在 get 和 put 指令中间，还会执行一些其他的指令。上下文切换有可能发生在执行这些指令的时候，所以并不是原子行的。</p>
<p>即使是 getValue() 这样的操作，虽然说他是原子操作，但是如果不加 synchronized 也可能会出问题. 下面的程序中，我们实现了一个自增函数 evenIncrement 并用 synchronized 修饰，在 run 中让他一直运行。在 main 中启动这个线程，并打印当前 i 的值。可以看到还是会出问题。问题有两个</p>
<ul>
<li>变量没有用 volatile 修饰</li>
<li>getValue 没有用 synchronized 修饰</li>
</ul>
<p>试了一下，即使 i 用 volatile 修饰了还是会出问题的</p>
<p>没有 synchronized 修饰时，程序允许 getValue 在状态不确定的情况下访问变量，所以会出问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicityTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span> </span>&#123; i++; i++; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            evenIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        AtomicityTest at = <span class="keyword">new</span> AtomicityTest();</span><br><span class="line">        exec.execute(at);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = at.getValue();</span><br><span class="line">            <span class="keyword">if</span>(val %<span class="number">2</span> !=<span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 423</span></span><br></pre></td></tr></table></figure>

<p>下面是一个更简单的例子，一个生成器给出一系列的数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber++;  <span class="comment">// Not thread-safe</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将变量声明为 volatile 可以告诉编译器不要对它进行优化。读写会被直接反应到内存中，而不是 cache. 而且还能防止指令重排。但是它并不表示这个自增是一个原子操作。</p>
<p>通常来说，如果有多个 task 操作一个 field，并且至少有一个会对他进行写操作，那么你就要讲他声明为 volatile。比如 flag 的操作。</p>
<p>为了测试上面的这个类，我们创建了如下的测试类</p>
<p>CircularSet 是一个容器类，用来存储生成器产生的数据。定义了一个数组，可以指定大小。 add/contains 使用 synchronized 修饰。主线程中，启动 10 个线程生产数据并存到容器中。理论上来说，如果线程安全，容器中不会有重复数据，如果有，则报错，结束进程。</p>
<p>这里一个比较巧妙的设置是，CircularSet 会存储一个下标，如果生产的值超出容量，他会循环利用之前的位置，覆盖之前的值。</p>
<p>可以在 SerialNumberGenerator 的 nextSerialNumber 方法前添加 synchronized 修饰修复这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialNumberChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CircularSet serials = <span class="keyword">new</span> CircularSet(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> serial = SerialNumberGenerator.nextSerialNumber();</span><br><span class="line">                <span class="keyword">if</span> (serials.contains(serial)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Duplicate: &quot;</span> + serial);</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                serials.add(serial);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SerialChecker());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Integer(args[<span class="number">0</span>]));</span><br><span class="line">            System.out.println(<span class="string">&quot;No duplicates detected&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        len = size;</span><br><span class="line">        <span class="comment">// Initialize to a value not produced by the SerialNumberChecker</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            array[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        array[index] = i;</span><br><span class="line">        <span class="comment">// Wrap index and write over old elements</span></span><br><span class="line">        index = ++index % len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == val) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Duplicate: 47</span></span><br></pre></td></tr></table></figure>

<h3 id="Atomic-classes"><a href="#Atomic-classes" class="headerlink" title="Atomic classes"></a>Atomic classes</h3><p>Java 5 引入了原子类，如 AtomicInteger, AtomicLong 和 AtomicReference 等提供原子级别的更新操作。</p>
<blockquote>
<p>boolean compareAndSet(expectedValue, updateValue);</p>
</blockquote>
<p>他们做过优化，可以保证机器层面的原子性，一般来说，你可以放心使用。下面我们用他们来重写之前的测试类 AtomicityTest.java. 内部逻辑和之前一样，我们将 volatile 和 synchronized 关键字都去了，同时定义一个 main 函数，在里面使用 Timer 设置程序 5s 之后退出，到程序结束为止一切运行正常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">evenIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i.addAndGet(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            evenIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Aborting&quot;</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        AtomicIntegerTest ait = <span class="keyword">new</span> AtomicIntegerTest();</span><br><span class="line">        exec.execute(ait);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = ait.getValue();</span><br><span class="line">            <span class="keyword">if</span> (val % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，我们使用 AtomicInteger 重写 EvenGenerator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger currentEvenValue = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentEvenValue.addAndGet(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> AtomicEvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 Atomic class 可以解决原子行问题，但是还是强烈推荐使用锁机制。</p>
<h3 id="Critial-sections"><a href="#Critial-sections" class="headerlink" title="Critial sections"></a>Critial sections</h3><p>我们可以通过 critical sections 的方式，只对一段代码进行保护而不是整个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject) &#123;</span><br><span class="line">    <span class="comment">// This code can be accessed</span></span><br><span class="line">    <span class="comment">// by only one task at a time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式也叫做 synchronized block. 如果此时 syncObject 被其他 task lock 了，那么当前 task 会一直等待，直到 lock 被释放。以下示例对两种 lock 方式进行性能比较</p>
<p>Pair 是我们要操作的对象，线程不安全，这个模型就是内部存两个 int 变量，我们的目标是保证这两个变量想等。还有一个 checkState 方法，如果两个变量值不同，则抛异常。</p>
<p>PairManager 是一个抽象类，里面声明了一个用来存储 pair 的 list, 使用 Collections.synchronizedList() 得到，所以线程安全。 getPair() 也用 synchronized 修饰，线程安全。 store 虽然没有修饰但是只在实现类中调用，调用的时候会加 synchronized 限制。</p>
<p>PairManager1， PairManager2 都是 PairManager 的实现，区别是一个用了 method level 的 lock， 一个用了 block level 的 lock</p>
<p>PairManipulator 代表使用 PairManager 的 task, 我们通过它来启动多线程实现 PM 的 increment 调用</p>
<p>PairChecker 也是一个多线程的 task 它用来检测 PM 的状态并记录检测次数</p>
<p>CriticalSection 相当于 client，将上面说的这些元素整合并调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriticalSection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Test the two different approaches:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testApproaches</span><span class="params">(PairManager pman1, PairManager pman2)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        PairManipulator</span><br><span class="line">                pm1 = <span class="keyword">new</span> PairManipulator(pman1),</span><br><span class="line">                pm2 = <span class="keyword">new</span> PairManipulator(pman2);</span><br><span class="line">        PairChecker</span><br><span class="line">                pcheck1 = <span class="keyword">new</span> PairChecker(pman1),</span><br><span class="line">                pcheck2 = <span class="keyword">new</span> PairChecker(pman2);</span><br><span class="line">        exec.execute(pm1);</span><br><span class="line">        exec.execute(pm2);</span><br><span class="line">        exec.execute(pcheck1);</span><br><span class="line">        exec.execute(pcheck2);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Sleep interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;pm1: &quot;</span> + pm1 + <span class="string">&quot;\npm2: &quot;</span> + pm2);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PairManager</span><br><span class="line">                pman1 = <span class="keyword">new</span> PairManager1(),</span><br><span class="line">                pman2 = <span class="keyword">new</span> PairManager2();</span><br><span class="line">        testApproaches(pman1, pman2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;x: &quot;</span> + x + <span class="string">&quot;, y: &quot;</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairValuesNotEqualException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PairValuesNotEqualException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="string">&quot;Pair values not equal: &quot;</span> + Pair.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PairValuesNotEqualException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PairManager</span> </span>&#123;</span><br><span class="line">    AtomicInteger checkCounter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">protected</span> Pair p = <span class="keyword">new</span> Pair();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Pair&gt; storage = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Pair <span class="title">getPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make a copy to keep the original safe:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(p.getX(), p.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assme this is a time consuming peration</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(Pair p)</span> </span>&#123;</span><br><span class="line">        storage.add(p);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairManager1</span> <span class="keyword">extends</span> <span class="title">PairManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        p.incrementX();</span><br><span class="line">        p.incrementY();</span><br><span class="line">        store(getPair());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use a critical section</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairManager2</span> <span class="keyword">extends</span> <span class="title">PairManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Pair temp;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            p.incrementX();</span><br><span class="line">            p.incrementY();</span><br><span class="line">            temp = getPair();</span><br><span class="line">        &#125;</span><br><span class="line">        store(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairManipulator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PairManager pm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PairManipulator</span><span class="params">(PairManager pm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pm = pm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            pm.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pair: &quot;</span> + pm.getPair() + <span class="string">&quot; checkCounter = &quot;</span> + pm.checkCounter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairChecker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PairManager pm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PairChecker</span><span class="params">(PairManager pm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pm = pm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            pm.checkCounter.incrementAndGet();</span><br><span class="line">            pm.getPair().checkState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pm1: Pair: x: 42, y: 42 checkCounter = 2</span></span><br><span class="line"><span class="comment">// pm2: Pair: x: 42, y: 42 checkCounter = 2133930</span></span><br></pre></td></tr></table></figure>

<p>PS: Note that the synchronized keyword is not part of the method signature and thus may be added during overriding. </p>
<p>synchronized 不是方法签名的一部分！！</p>
<p>从输出的实验结果可以看到方法锁的可使用率要比 block 锁低很多，完全是碾压级别的差距。block 类型的锁可以提供更多的 unlock time.</p>
<p>下面通过使用 Lock 类来进行精确锁, 共能和之前的例子类似，只不过新实现了两个 PairManager 类，一个还是用方法级别的锁， ExplicitPairManager1 由于已经加了 synchronized 的了，里面的 lock 其实没什么用，去掉也不影响结果</p>
<p>ExplicitPairManager1 中直接使用了 Lock 类进行 block level 的锁。运行结果失败，会抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitCriticalSection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PairManager</span><br><span class="line">                pman1 = <span class="keyword">new</span> ExplicitPairManager1(),</span><br><span class="line">                pman2 = <span class="keyword">new</span> ExplicitPairManager2();</span><br><span class="line">        CriticalSection.testApproaches(pman1, pman2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExplicitPairManager1</span> <span class="keyword">extends</span> <span class="title">PairManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.incrementX();</span><br><span class="line">            p.incrementY();</span><br><span class="line">            store(getPair());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExplicitPairManager2</span> <span class="keyword">extends</span> <span class="title">PairManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Pair temp;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.incrementX();</span><br><span class="line">            p.incrementY();</span><br><span class="line">            temp = getPair();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        store(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// public Pair getPair() &#123;</span></span><br><span class="line">    <span class="comment">//     lock.lock();</span></span><br><span class="line">    <span class="comment">//     try &#123;</span></span><br><span class="line">    <span class="comment">//         return new Pair(p.getX(), p.getY());</span></span><br><span class="line">    <span class="comment">//     &#125; finally &#123;</span></span><br><span class="line">    <span class="comment">//         lock.unlock();</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Exception in thread &quot;pool-1-thread-4&quot; org.jz.c23.Pair$PairValuesNotEqualException: Pair values not equal: x: 2, y: 1</span></span><br><span class="line"><span class="comment">//     at org.jz.c23.Pair.checkState(CriticalSection.java:83)</span></span><br><span class="line"><span class="comment">//     at org.jz.c23.PairChecker.run(CriticalSection.java:163)</span></span><br><span class="line"><span class="comment">// pm1: Pair: x: 127, y: 127 checkCounter = 3</span></span><br><span class="line"><span class="comment">// pm2: Pair: x: 127, y: 127 checkCounter = 1816160</span></span><br></pre></td></tr></table></figure>

<p>搜索了一下，发先这个<a target="_blank" rel="noopener" href="https://blog.nex3z.com/2016/07/03/%E6%B7%B7%E7%94%A8%E5%90%8C%E6%AD%A5%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/">博客</a>说的挺好. 总结一下就是 getPair 用的 synchronized 语法，而 increment 用的 Lock 类的方法，两个都是锁，但是拿到的锁是不一样的，将 getPair 重写一下，也用同样的 Lock 类提供的锁即可修复。</p>
<h3 id="Synchronizing-on-other-objects"><a href="#Synchronizing-on-other-objects" class="headerlink" title="Synchronizing on other objects"></a>Synchronizing on other objects</h3><p>synchronized block 的写法中，需要给出一个 lock 的对象，一般来说我们都会使用 this 作为参数，表示持有这个方法的对象就是我们要 lock 的对象。当然你也可以指定另一个对象，但是你一定要理清楚自己的业务逻辑，知道你要 lock 的对象是哪一个</p>
<p>下面例子中声明了一个 DualSynch 类，里面有两个方法，f(), g() 分别打印 5 次，f() 是 method lock，就是锁住自己的意思，g() 在内部指定锁住一个内部成员变量。在主函数中，我们通过新起线程调用 f()，在主函数中调用 g()。可以看到虽然外部 class 实体也有 lock 但是和内部的变量是不冲突的，两个 task 可以一起执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DualSynch ds = <span class="keyword">new</span> DualSynch();</span><br><span class="line">        <span class="keyword">new</span> Thread(ds::f).start();</span><br><span class="line">        ds.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualSynch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object syncObject = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (syncObject) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;g()&quot;</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g()</span></span><br><span class="line"><span class="comment">// f()</span></span><br><span class="line"><span class="comment">// f()</span></span><br><span class="line"><span class="comment">// g()</span></span><br><span class="line"><span class="comment">// f()</span></span><br><span class="line"><span class="comment">// f()</span></span><br><span class="line"><span class="comment">// f()</span></span><br><span class="line"><span class="comment">// g()</span></span><br><span class="line"><span class="comment">// g()</span></span><br><span class="line"><span class="comment">// g()</span></span><br></pre></td></tr></table></figure>

<h3 id="Thread-local-storage"><a href="#Thread-local-storage" class="headerlink" title="Thread local storage"></a>Thread local storage</h3><p>Java 还提供了另一种解决多线程使用共享资源时的冲突问题，叫做 ThreadLocal.</p>
<p>对与被管理的变量，Thread local storage 会在不同的 thread 总为变量创建单独的副本，所以各个 thread 彼此不会被影响到。</p>
<p>下面的例子中 Accessor 是一个具体的 task，他会通过 while 循环不停的调用 holder 的 increment 方法并答应对应的值。</p>
<p>ThreadLocalVariableHolder 中持有一个 Integer 类型的 ThreadLocal 变量，提供自增长方法，在 main 函数中，启动五个线程，调用自增方法并打印。</p>
<p>可以看到每个线程中拿到的 integer 值都是不一样的，而且相互不影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalVariableHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rand.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value.set(value.get() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Accessor(i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Accessor</span><span class="params">(<span class="keyword">int</span> idn)</span> </span>&#123;</span><br><span class="line">        id = idn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            ThreadLocalVariableHolder.increment();</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span> + id + <span class="string">&quot;: &quot;</span> + ThreadLocalVariableHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #0: 9259</span></span><br><span class="line"><span class="comment">// #1: 556</span></span><br><span class="line"><span class="comment">// #2: 6694</span></span><br><span class="line"><span class="comment">// #0: 9260</span></span><br><span class="line"><span class="comment">// #2: 6695</span></span><br><span class="line"><span class="comment">// #1: 557</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="Terminating-tasks"><a href="#Terminating-tasks" class="headerlink" title="Terminating tasks"></a>Terminating tasks</h2><p>本章介绍如何外部结束 task</p>
<h3 id="The-ornamental-garden"><a href="#The-ornamental-garden" class="headerlink" title="The ornamental garden"></a>The ornamental garden</h3><p>下面的例子模拟一个植物园的场景，植物园入口处有闸机，通过统计闸机记述统计园内总人数。只做演示用，没有其他深意。</p>
<p>Count 用来管理总人数，提供 increment 和 value 方法，且都是 synchronized 修饰的。increment 中还包含一个 yield 方法用来提高多线程问题出发的概率。</p>
<p>Entrance 表示入口，他持有一个 Count 的静态变量，用来合计总人数。同时还申明了一个 number 的成员变量，用来审计从这个门进入的游客数量。声明 entrances 这个静态变量，用于线程结束后的统计，cancel 声明为 volatile 用来控制 task 的结束。</p>
<p>OrnamentalGarden 为 client 端，他的 main 函数会启动五个线程模拟入园操作。3s 后结束，分别答应 number 加和以及 count 值做统计，两个值应该是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrnamentalGarden</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Entrance(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Run for a while then stop and collect the data:</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        Entrance.cancel();</span><br><span class="line">        exec.shutdown();</span><br><span class="line">        <span class="keyword">if</span> (!exec.awaitTermination(<span class="number">250</span>, TimeUnit.MILLISECONDS))</span><br><span class="line">            System.out.println(<span class="string">&quot;Some task were not terminated!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Total: &quot;</span> + Entrance.getTotalCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum of Entrances: &quot;</span> + Entrance.sumEntrances());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove the synchronized keyword to see counting fail:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = count;</span><br><span class="line">        <span class="keyword">if</span> (rand.nextBoolean()) <span class="comment">// Yield half the time</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">return</span> (count = ++temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entrance</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Count count = <span class="keyword">new</span> Count();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Entrance&gt; entrances = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Doesn&#x27;t need synchronization to read:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomic operation on a volatile field:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        canceled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entrance</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="comment">// Keep this task in a list. Also prevents garbage collection of dead tasks:</span></span><br><span class="line">        entrances.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!canceled) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                ++number;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span> + <span class="string">&quot; Total: &quot;</span> + count.increment());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Sleep interrupted&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entrance &quot;</span> + id + <span class="string">&quot;: &quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotalCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumEntrances</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Entrance entrance : entrances) &#123;</span><br><span class="line">            sum += entrance.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Entrance 0: 1 Total: 1</span></span><br><span class="line"><span class="comment">// Entrance 2: 1 Total: 3</span></span><br><span class="line"><span class="comment">// Entrance 1: 1 Total: 2</span></span><br><span class="line"><span class="comment">// Entrance 3: 1 Total: 4</span></span><br><span class="line"><span class="comment">// Entrance 4: 1 Total: 5</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Entrance 2: 30 Total: 150</span></span><br><span class="line"><span class="comment">// Entrance 1: 30 Total: 148</span></span><br><span class="line"><span class="comment">// Stopping Entrance 3: 30</span></span><br><span class="line"><span class="comment">// Stopping Entrance 4: 30</span></span><br><span class="line"><span class="comment">// Stopping Entrance 1: 30</span></span><br><span class="line"><span class="comment">// Stopping Entrance 2: 30</span></span><br><span class="line"><span class="comment">// Stopping Entrance 0: 30</span></span><br><span class="line"><span class="comment">// Total: 150</span></span><br><span class="line"><span class="comment">// Sum of Entrances: 150</span></span><br></pre></td></tr></table></figure>

<h3 id="Terminating-when-blocked"><a href="#Terminating-when-blocked" class="headerlink" title="Terminating when blocked"></a>Terminating when blocked</h3><h4 id="Thread-states"><a href="#Thread-states" class="headerlink" title="Thread states"></a>Thread states</h4><p>一个 Thread 可能处于四种状态中的任意一种</p>
<ol>
<li>New: 这种状态很短暂，在创建线程的时候出现。系统为他配置所需要的资源，完成后，scheduler 会把它置于 runnable 或者 blocked</li>
<li>Runnable: 当 CPU 有空闲时就可以运行它</li>
<li>Blocked: 可以运行，但是被阻止了。CPU 会直接跳过它。</li>
<li>Dead: task 结束了，不会再被 schedule。从 run() 中返回，或者被 interrupted 时会处于这种状态。</li>
</ol>
<h4 id="Becoming-blocked"><a href="#Becoming-blocked" class="headerlink" title="Becoming blocked"></a>Becoming blocked</h4><p>一下情况会导致 task 进入 block 状态</p>
<ul>
<li>调用 sleep() 方法</li>
<li>调用 wait() 方法，可以调用 notify()/notifyAll() 解除</li>
<li>等待 I/O 完成</li>
<li>调用其他被 lock 的方法时</li>
</ul>
<h4 id="Interruption"><a href="#Interruption" class="headerlink" title="Interruption"></a>Interruption</h4><p>和你预期的一样，在 thread 中间打断它要比等到它出来，判断 cancel flag 结束要复杂的多，你打断 thread 的时候可能要处理很多 clean up 的操作。</p>
<p>你可以通过 Thread.interrupt() 方法打断线程，这个方法会将线程设置为 interrupted 状态，然后这个线程就会抛出 InterruptedException. 这个状态会在异常抛出或者调用 Thread.interrupted() 方法的时候置位。interrupted() 是另一种结束 run() 而不抛异常的方法。</p>
<p>为了调用 interrupt() 方法，你需要持有 Thread 对象。Java 提供的 concurrent 包让你避免直接使用 Thread，你可以用 Executor 来完成这类工作。shutdownNow() 会向它开启的所有线程发送 interrupt() 指令。如果你想单独控制某个 task 你可以使用 Executor 的 submit() 方法，它会返回 Feature 对象，你可以调用 feature.cancel(true) 来给对应的 task 传递 interrupt 指令。</p>
<p>下面是通过 feature.cancel() 来中断线程的测试, 定义了三种 block</p>
<p>SleepBlocked: 普通的 Runnable 实现，在 run 方法中，sleep 100s 作为 block</p>
<p>IOBlocked: 普通的 Runnable 实现，run 中读取输入流的内容</p>
<p>SynchronizedBlocked: f() 中无限循环调用 yield, 在构造函数中新起一个线程，调用 f(), 然后 main 中通过 test 起新线程制造 lock</p>
<p>Interrupting: 测试类， 写了一个 test 方法，接收 Runnable 实现，并通过 submit() 运行，然后通过 cancel(true) 中断 task. main 函数中将之前定义的 block 分别进行 test。</p>
<p>从输出可以看出，你可以 interrupt sleep 类型的 block，但是不能打断 IO 或者 Synchronized 类型的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Runnable r)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Future&lt;?&gt; f = exec.submit(r);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Interrupting &quot;</span> + r.getClass().getName());</span><br><span class="line">        f.cancel(<span class="keyword">true</span>); <span class="comment">// Interrupts if running</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Interrupt sent to &quot;</span> + r.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> SleepBlocked());</span><br><span class="line">        test(<span class="keyword">new</span> IOBlocked(System.in));</span><br><span class="line">        test(<span class="keyword">new</span> SynchronizedBlocked());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Aborting with System.exit(0)&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SleepBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;InterruptedException&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Existing SleepBlocked.run()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOBlocked</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Waiting for read(): &quot;</span>);</span><br><span class="line">            in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted from blocked I/O&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Exiting IOBlocked.run()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBlocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                f(); <span class="comment">// Lock acquired by this thread</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Trying to call f()&quot;</span>);</span><br><span class="line">        f();</span><br><span class="line">        System.out.println(<span class="string">&quot;Exiting SynchronizedBlocked.run()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interrupting org.jz.c23.SleepBlocked</span></span><br><span class="line"><span class="comment">// Interrupt sent to org.jz.c23.SleepBlocked</span></span><br><span class="line"><span class="comment">// InterruptedException</span></span><br><span class="line"><span class="comment">// Existing SleepBlocked.run()</span></span><br><span class="line"><span class="comment">// Waiting for read(): </span></span><br><span class="line"><span class="comment">// Interrupting org.jz.c23.IOBlocked</span></span><br><span class="line"><span class="comment">// Interrupt sent to org.jz.c23.IOBlocked</span></span><br><span class="line"><span class="comment">// Trying to call f()</span></span><br><span class="line"><span class="comment">// Interrupting org.jz.c23.SynchronizedBlocked</span></span><br><span class="line"><span class="comment">// Interrupt sent to org.jz.c23.SynchronizedBlocked</span></span><br><span class="line"><span class="comment">// Aborting with System.exit(0)</span></span><br></pre></td></tr></table></figure>

<p>有时你可以通过关闭底层的 resource 来中断 IO, 从输出可以看到， Socket 的输入流是通过异常关闭的，而 System.in 不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseResource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket server  = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        InputStream socketInput = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).getInputStream();</span><br><span class="line"></span><br><span class="line">        exec.execute(<span class="keyword">new</span> IOBlocked(socketInput));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> IOBlocked(System.in));</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shutting down all threads&quot;</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Closing &quot;</span> + socketInput.getClass().getName());</span><br><span class="line">        socketInput.close(); <span class="comment">// Releases blocked thread</span></span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Closing &quot;</span> + System.in.getClass().getName());</span><br><span class="line">        System.in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Waiting for read(): </span></span><br><span class="line"><span class="comment">// Waiting for read(): </span></span><br><span class="line"><span class="comment">// Shutting down all threads</span></span><br><span class="line"><span class="comment">// Closing java.net.SocketInputStream</span></span><br><span class="line"><span class="comment">// Interrupted from blocked I/O</span></span><br><span class="line"><span class="comment">// Exiting IOBlocked.run()</span></span><br><span class="line"><span class="comment">// Closing java.io.BufferedInputStream</span></span><br><span class="line"><span class="comment">// Exiting IOBlocked.run()</span></span><br></pre></td></tr></table></figure>

<p>好消息是 nio 相关的类有提供更好的终端 IO 的方法. blocked nio channels 会自动相应 interrupt 信号。</p>
<p>从输出可以看到，关闭底层的 channel 会释放 block，虽然这种方式和少用到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOInterruption</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        InetSocketAddress isa = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">        SocketChannel sc1 = SocketChannel.open(isa);</span><br><span class="line">        SocketChannel sc2 = SocketChannel.open(isa);</span><br><span class="line">        Future&lt;?&gt; f = exec.submit(<span class="keyword">new</span> NIOBlocked(sc1));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> NIOBlocked(sc2));</span><br><span class="line">        exec.shutdown();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Produce an interrupt via cancel;</span></span><br><span class="line">        f.cancel(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Release the block by closing the channel</span></span><br><span class="line">        sc2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NIOBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel sc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOBlocked</span><span class="params">(SocketChannel sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sc = sc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Waiting for read() in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">            sc.read(ByteBuffer.allocate(<span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClosedByInterruptException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ClosedByInterruptException&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AsynchronousCloseException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;AsynchronousCloseException&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Exiting NIOBlocked.run() &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Waiting for read() in org.jz.c23.NIOBlocked@2bc68519</span></span><br><span class="line"><span class="comment">// Waiting for read() in org.jz.c23.NIOBlocked@50b0c91f</span></span><br><span class="line"><span class="comment">// ClosedByInterruptException</span></span><br><span class="line"><span class="comment">// Exiting NIOBlocked.run() org.jz.c23.NIOBlocked@2bc68519</span></span><br><span class="line"><span class="comment">// AsynchronousCloseException</span></span><br><span class="line"><span class="comment">// Exiting NIOBlocked.run() org.jz.c23.NIOBlocked@50b0c91f</span></span><br></pre></td></tr></table></figure>

<h4 id="Blocked-by-a-mutex"><a href="#Blocked-by-a-mutex" class="headerlink" title="Blocked by a mutex"></a>Blocked by a mutex</h4><p>从 Interrupting.java 的例子可以看到，如果我们调用一个对象的 synchronized 方法，如果该方法的 lock 已经被获取了，那么这个 task 会 block 并等到 lock 被释放后再调用。下面的例子展示了同一个 task 如何多次获取同一个对象的锁</p>
<p>MultiLock 有两个方法 f, g 分别调用对方，并用 synchronized 关键字修饰。每次方法被调用时，方法的实例都会被 lock 一次。</p>
<p>举一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1() calling f2() with count &quot;</span> + count);</span><br><span class="line">            f2(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2() calling f1() with count &quot;</span> + count);</span><br><span class="line">            f1(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MultiLock multiLock = <span class="keyword">new</span> MultiLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; multiLock.f1(<span class="number">10</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// f1() calling f2() with count 9</span></span><br><span class="line"><span class="comment">// f2() calling f1() with count 8</span></span><br><span class="line"><span class="comment">// f1() calling f2() with count 7</span></span><br><span class="line"><span class="comment">// f2() calling f1() with count 6</span></span><br><span class="line"><span class="comment">// f1() calling f2() with count 5</span></span><br><span class="line"><span class="comment">// f2() calling f1() with count 4</span></span><br><span class="line"><span class="comment">// f1() calling f2() with count 3</span></span><br><span class="line"><span class="comment">// f2() calling f1() with count 2</span></span><br><span class="line"><span class="comment">// f1() calling f2() with count 1</span></span><br><span class="line"><span class="comment">// f2() calling f1() with count 0</span></span><br></pre></td></tr></table></figure>

<p>这个例子的说明不是很懂，但是大概就是 concurrency lib 的 RenntrantLocks 提供了一种打断机制</p>
<p>BlockedMutex 持有 ReentrantLock 变量，并在构造函数中 lock，提供 f() 方法，调用 lock.lockInterruptibly(); 由于构造中的 lock，这个方法会一直 block。</p>
<p>Blocked2 新建 BlockedMutex 对象，导致上锁。然后调用 f() 被 block。</p>
<p>Interrupting2 在启动 Blocked2 之后 1s 进行打断，interrupt 成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupting2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked2());</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Issuing t.interrupt()&quot;</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockedMutex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockedMutex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Acquire it right away, to demonstrate interruption of a task blocked on a ReentrantLock</span></span><br><span class="line">        lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This will never be available to a second task</span></span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">            System.out.println(<span class="string">&quot;lock acquired in f()&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interrupted from lock acquisition in f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocked2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    BlockedMutex blocked = <span class="keyword">new</span> BlockedMutex();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for f() in BlockedMutex&quot;</span>);</span><br><span class="line">        blocked.f();</span><br><span class="line">        System.out.println(<span class="string">&quot;Broken out of blocked call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Waiting for f() in BlockedMutex</span></span><br><span class="line"><span class="comment">// Issuing t.interrupt()</span></span><br><span class="line"><span class="comment">// Interrupted from lock acquisition in f()</span></span><br><span class="line"><span class="comment">// Broken out of blocked call</span></span><br></pre></td></tr></table></figure>

<h3 id="Checking-for-an-interrupt"><a href="#Checking-for-an-interrupt" class="headerlink" title="Checking for an interrupt"></a>Checking for an interrupt</h3><p>TBD</p>
<h2 id="Cooperation-between-tasks"><a href="#Cooperation-between-tasks" class="headerlink" title="Cooperation between tasks"></a>Cooperation between tasks</h2><p>通过之前的章节，我们知道可以通过互斥锁来控制多个 task 对一个资源的访问。</p>
<p>这章我们会学习如何通过内置方法，协调多个 task 之间对一个资源的调用。Object 提供了 wait()/notifyAll()，concurrent lib 提供了 await()/signal() 来完成这些功能。</p>
<h3 id="wait-and-notifyAll"><a href="#wait-and-notifyAll" class="headerlink" title="wait() and notifyAll()"></a>wait() and notifyAll()</h3><p>下面将 wait/notifyAll 应用在汽车打蜡的场景</p>
<p>Car 代表将会被 lock 的类, 提供了四个方法，使用 synchronized 修饰，分别是打蜡，抛光，等待上蜡，等待抛光。</p>
<p>WaxOn 代表上蜡的 task, 接收一个 car 做参数，在 run 中，打印状态并将 car 的 flag 置位 true，等待抛光</p>
<p>WaxOff 代表抛光的 task, 接收一个 car 做参数，在 run 中，打印状态并将 car 的 flag 置位 false, 并等待打蜡</p>
<p>WaxOMatic 新建 car 对象，并启动两个 task 让他们轮流操作 car, 并在一定时间后结束操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaxOMatic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> WaxOff(car));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> WaxOn(car));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        exec.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> waxOn = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waxed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        waxOn = <span class="keyword">true</span>; <span class="comment">// Ready to buff</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buffed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        waxOn = <span class="keyword">false</span>; <span class="comment">// Ready for another coat of wax</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitForWaxing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (waxOn == <span class="keyword">false</span>)</span><br><span class="line">            wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitForBuffing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (waxOn == <span class="keyword">true</span>)</span><br><span class="line">            wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaxOn</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaxOn</span><span class="params">(Car c)</span> </span>&#123;</span><br><span class="line">        car = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Wax On!&quot;</span>);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                car.waxed();</span><br><span class="line">                car.waitForBuffing();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Ending Wax On task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaxOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaxOff</span><span class="params">(Car c)</span> </span>&#123;</span><br><span class="line">        car = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                car.waitForWaxing();</span><br><span class="line">                System.out.println(<span class="string">&quot;Wax Off!&quot;</span>);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">                car.buffed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exiting via interrupt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Ending Wax Off task&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wax On!</span></span><br><span class="line"><span class="comment">// Wax Off!</span></span><br><span class="line"><span class="comment">// Wax On!</span></span><br><span class="line"><span class="comment">// Wax Off!</span></span><br><span class="line"><span class="comment">// Wax On!</span></span><br><span class="line"><span class="comment">// Wax Off!</span></span><br><span class="line"><span class="comment">// Wax On!</span></span><br><span class="line"><span class="comment">// Wax Off!</span></span><br><span class="line"><span class="comment">// Wax On!</span></span><br><span class="line"><span class="comment">// Wax Off!</span></span><br><span class="line"><span class="comment">// Exiting via interrupt</span></span><br><span class="line"><span class="comment">// Ending Wax Off task</span></span><br><span class="line"><span class="comment">// Exiting via interrupt</span></span><br><span class="line"><span class="comment">// Ending Wax On task</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中需要强调的一点是，你必须将 wait() 用 while 包裹起来，因为</p>
<ul>
<li>多个 task 等待同一个 lock 时，前面的 task 可能会改变某些条件，当前的 task 需要 block 住知道条件允许</li>
<li>当前 task 唤醒后，可能条件不允许，他要继续等待</li>
<li>当前 task 唤醒后，可能操作的对象还在 block 中，那它就要继续 wait</li>
</ul>
<h4 id="Missed-Singals"><a href="#Missed-Singals" class="headerlink" title="Missed Singals"></a>Missed Singals</h4><p>当两个 task 在通过 notify()/wait() 或者 notifyAll()/wait() 协调工作时，有可能错过一些指令，比如下面的例子</p>
<p><setup condition for T2> 会组织 T2 调用 wait</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">T1: </span><br><span class="line">synchronized(sharedMonitor) &#123;</span><br><span class="line">    &lt;setup condition for T2&gt;</span><br><span class="line">    sharedMonitor.notify(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2: </span><br><span class="line">while(someCondition) &#123;</span><br><span class="line">    // Point 1   </span><br><span class="line">    synchronized(sharedMonitor) </span><br><span class="line">    &#123;     </span><br><span class="line">        sharedMonitor.wait();   </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>假设 T2 通过了 someCondition 的验证，在 Point1 时，切换到 T1，然后 T1 拿到锁并运行就结束，发出 notify() 这时切换回 T2 继续运行，发现 T2 一直等待，就死锁了。</p>
<p>T2 的正确写法应该是</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(sharedMonitor) &#123;</span><br><span class="line">    while(someCondition)</span><br><span class="line">        sharedMonitor.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 T1 先运行，当返回到 T2 时，回判断 condition 不满足，将不会进入等待状态。相反，当 T2 先运行，他会进如 wait, 等待 T1 唤醒</p>
<p>PS: 看的很迷，我的逻辑应该是错的，但是我放弃思考了。。。</p>
<h3 id="notify-vs-notifyAll"><a href="#notify-vs-notifyAll" class="headerlink" title="notify() vs notifyAll()"></a>notify() vs notifyAll()</h3><p>notify 是 notifyAll 的一个优化，由于 notify 只会唤醒一个 task. 如果你要使用它，请确保，在你调用的时候只有想要调用的那个 task 是处于等待状态的。</p>
<p>notifyAll() 并不会 wake up “all waiting tasks”, only the tasks that are waiting on a particular lock are awoken when notifyAll() is called/or that lock</p>
<p>实验说明如下：</p>
<p>Blocker 是操作的对象类，提供三个方法，waitingCall 用来停留在 wait() 状态，prod/prodAll 分别是唤醒单个和唤醒全部线程。</p>
<p>Task1/2 分别是两个 task, 功能一样，唯一的作用是提供提供两个操作类进行实验。</p>
<p>NotifyVsNotifyAll 为 client 类，先启动 5 个 Task1，再启动 1 个 Task2. 6 个线程都停留在 wait 状态。然后通过 timer 分别出发 Task1 的 prod 和 prodAll 方法，从输出可以看到，当调用 notify 时只有一个 Task1 被唤醒，当调用 notifyAll 时，所有 Task1 都醒了，Task2 毫无反应。只有最后结束时调用了 Task2 的 prodAll 时，Task2 对应的线程被唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyVsNotifyAll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Task());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Task2());</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="keyword">boolean</span> prod = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (prod) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;\nnotify() &quot;</span>);</span><br><span class="line">                    Task.blocker.prod();</span><br><span class="line">                    prod = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;\nnotifyAll() &quot;</span>);</span><br><span class="line">                    Task.blocker.prodAll();</span><br><span class="line">                    prod = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        timer.cancel();</span><br><span class="line">        System.out.println(<span class="string">&quot;\nTimer canceled&quot;</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Task2.blocker.prodAll() &quot;</span>);</span><br><span class="line">        Task2.blocker.prodAll();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\nShutting down&quot;</span>);</span><br><span class="line">        exec.shutdownNow();<span class="comment">// Interrupt all tasks</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitingCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                wait();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// OK to exit this way</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">prod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">prodAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Blocker blocker = <span class="keyword">new</span> Blocker();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        blocker.waitingCall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A separate Blocker object:</span></span><br><span class="line">    <span class="keyword">static</span> Blocker blocker = <span class="keyword">new</span> Blocker();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        blocker.waitingCall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// notify() </span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-1,5,main] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// notifyAll() </span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-2,5,main] </span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-1,5,main] </span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-5,5,main] </span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-4,5,main] </span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-3,5,main] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Timer canceled</span></span><br><span class="line"><span class="comment">// Task2.blocker.prodAll() </span></span><br><span class="line"><span class="comment">// Thread[pool-1-thread-6,5,main] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Shutting down</span></span><br></pre></td></tr></table></figure>

<p>暂时就先看到这儿把，耐心已经磨光了，以后有动力了再接着看</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jack-zheng.github.io/hexo/hexo/2021/08/17/Git-multiple-account/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/jack.jpg">
      <meta itemprop="name" content="Jack Zheng">
      <meta itemprop="description" content="我是张江搬砖小码农, 知识搬运工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackpot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/08/17/Git-multiple-account/" class="post-title-link" itemprop="url">Git 多账户设置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-17 12:56:20" itemprop="dateCreated datePublished" datetime="2021-08-17T12:56:20+08:00">2021-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-14 10:41:39" itemprop="dateModified" datetime="2021-10-14T10:41:39+08:00">2021-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">小工具</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>公司使用 GitHub 企业版管理代码，我自己也时常会需要在公用版 Github 上更新一些代码，经常要交互使用。2021-08-13 的时候，GitHub 官方静止了 password 类型提交代码，这不只能找找怎么本地配置双账号了，解决方案如下</p>
<p>前置，初始化配置：</p>
<ol>
<li>删除 ～/.gitconfig 中的账户信息</li>
<li>删除 ～/.ssh 下的配置信息</li>
</ol>
<p>配置：</p>
<ol>
<li>cd 到 ～/.ssh 目录下运行 <code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code> 生成公私密码，之前参考了官方文档指定类型 ed25519, 不知道为啥，配置不生效</li>
<li>在提示 <code>Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]</code> 时添加后缀指定环境, 我本地的配置情况 <code>id_rsa_github id_rsa_github.pub id_rsa_sap id_rsa_sap.pub</code></li>
<li>后面直接回车到文件生成成功。</li>
<li>运行 <code>eval &quot;$(ssh-agent -s)&quot;</code> 启动代理并运行 <code>ssh-add ~/.ssh/id_rsa_github</code> 和 <code>ssh-add ~/.ssh/id_rsa_sap</code> 将私钥添加到密钥链中。通过 <code>ssh-add -l</code> 可以查看已经添加的 key 信息. PS: 如果你是 Mac 系统需要加一个 -K 不然重启之后 key 就没了 <code>ssh-add -K ~/.ssh/id_rsa_github</code></li>
<li>在 ~/.ssh/config 文件中配置账号，网站的对应关系, 示例如下</li>
<li>打开 github 网站，将 id_rsa_github.pub 这个公钥信息添加到目标网站 头像 -&gt; Settings -&gt; SSH and GPG keys -&gt;  New SSH key</li>
<li>测试配置是否成功，终端输入 <code>ssh -T git@github.com</code> 和 <code>ssh -T git@github.wdf.sap.corp</code> 看提示信息是否正确</li>
<li>配置 commit 账号，如果没有设置，commit 的时候, git 会用电脑主机号作为提交账号。我本地是将常用的公司账号信息通过 git config –global 配置为全局信息，在自己的 repo 中通过 git config –local 单独配置</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Host github</span><br><span class="line">HostName github.com</span><br><span class="line">User jack-zheng</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"></span><br><span class="line">Host gitlab</span><br><span class="line">HostName github.wdf.sap.corp</span><br><span class="line">User Ixxxx</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_sap</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">官方文档</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jack-zheng.github.io/hexo/hexo/2021/08/11/Design-pattern-singleton-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/jack.jpg">
      <meta itemprop="name" content="Jack Zheng">
      <meta itemprop="description" content="我是张江搬砖小码农, 知识搬运工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jackpot">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/08/11/Design-pattern-singleton-md/" class="post-title-link" itemprop="url">单例模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-11 13:31:03" itemprop="dateCreated datePublished" datetime="2021-08-11T13:31:03+08:00">2021-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-14 10:41:39" itemprop="dateModified" datetime="2021-10-14T10:41:39+08:00">2021-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>目的：保证一个类只有一个实例，并提供一个访问他的全局访问点</p>
<p>关键代码：</p>
<ul>
<li>构造函数<strong>私有化</strong></li>
<li>私有静态变量</li>
<li>对外的静态方法</li>
</ul>
<p>介绍几种单例模式的实现方式 - 有种回字的几种写法的意思，略无聊</p>
<h2 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式 - 线程不安全"></a>懒汉式 - 线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单易懂，但是线程不安全</p>
<h2 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式 - 线程安全"></a>懒汉式 - 线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton02 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton02();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现简单，线程安全，方法体加锁比较耗资源，当 getInstance() 调用不频繁时可以使用</p>
<h2 id="饿汉式-线程安全"><a href="#饿汉式-线程安全" class="headerlink" title="饿汉式 - 线程安全"></a>饿汉式 - 线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton03 instance = <span class="keyword">new</span> Singleton03();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton03</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton03 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现简单，线程安全，通过 classloader 避免同步问题，缺点是类加载就初始化，浪费内存</p>
<h2 id="双检锁-双重校验锁-DCL-double-checked-locking"><a href="#双检锁-双重校验锁-DCL-double-checked-locking" class="headerlink" title="双检锁/双重校验锁 DCL double-checked locking"></a>双检锁/双重校验锁 DCL double-checked locking</h2><p>注意 volatile 的使用，避免指令重排</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton04 instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton04</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton04 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton04.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton04();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>略显复杂，但是性能良好效率高，懒加载，线程安全 Java 1.5 后有效。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xz816111/p/8470048.html">CNBLOG</a></li>
</ul>
<h2 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton05</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton05 INSTANCE = <span class="keyword">new</span> Singleton05();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton05</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton05 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现简单，线程安全，懒加载。效果和双检锁一致。但是由于只在被使用时才通过 classloader 加载，效率回更高</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton06 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上来说最安全，最简单的实现，不过不流行。 Effective Java 作者推荐的写法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/hexo/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/hexo/">1</a><span class="page-number current">2</span><a class="page-number" href="/hexo/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/hexo/page/20/">20</a><a class="extend next" rel="next" href="/hexo/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jack Zheng"
      src="/hexo/images/jack.jpg">
  <p class="site-author-name" itemprop="name">Jack Zheng</p>
  <div class="site-description" itemprop="description">我是张江搬砖小码农, 知识搬运工</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hexo/archives/">
        
          <span class="site-state-item-count">196</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/hexo/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/hexo/tags/">
          
        <span class="site-state-item-count">178</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jack Zheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15:50</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v5.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/hexo/lib/anime.min.js"></script>
  <script src="/hexo/lib/velocity/velocity.min.js"></script>
  <script src="/hexo/lib/velocity/velocity.ui.min.js"></script>

<script src="/hexo/js/utils.js"></script>

<script src="/hexo/js/motion.js"></script>


<script src="/hexo/js/schemes/muse.js"></script>


<script src="/hexo/js/next-boot.js"></script>




  




  
<script src="/hexo/js/local-search.js"></script>














  

  


</body>
</html>
